/*
 * @lc app=leetcode id=924 lang=cpp
 *
 * [924] Minimize Malware Spread
 */

// @lc code=start
// 1. BFS
// 2024-01-15 submission
// 68/68 cases passed
// Runtime: 180 ms, faster than 29.14% of cpp online submissions.
// Memory Usage: 75.1 MB, less than 6.67% of cpp online submissions.
class Solution {
public:
    int minMalwareSpread(vector<vector<int>>& graph, vector<int>& initial) {
        int n = graph.size();
        vector<vector<int>> adj(n);
        for (int i = 0; i < n; ++i) {
            for (int j = i + 1; j < n; ++j) {
                if (graph[i][j] == 1) {
                    adj[i].push_back(j);
                    adj[j].push_back(i);
                }
            }
        }
        int min_m = n + 1, res = n + 1;
        for (int i = 0; i < initial.size(); ++i) {
            int m = bfs(adj, initial, i);
            if (m < min_m) {
                min_m = m;
                res = initial[i];
            }
            else if (m == min_m) {
                res = min(res, initial[i]);
            }
        }
        return res;
    }

    int bfs(vector<vector<int>>& adj, vector<int>& initial, int idx) {
        int n = adj.size();
        unordered_set<int> infected;
        queue<int> q;
        for (int i = 0; i < initial.size(); ++i) {
            if (i != idx) {
                q.push(initial[i]);
                infected.insert(initial[i]);
            }
        }
        while (!q.empty()) {
            int cur = q.front();
            q.pop();
            for (int next : adj[cur]) {
                if (!infected.count(next)) {
                    q.push(next);
                    infected.insert(next);
                }
            }
        }
        return infected.size();
    }
};
// @lc code=end

// @lc code=start
// 2. 并查集
// 2024-01-15 submission
// 68/68 cases passed
// Runtime: 121 ms, faster than 99.26% of cpp online submissions.
// Memory Usage: 65.4 MB, less than 67.41% of cpp online submissions.
class Solution {
public:
    int find(vector<int>& parent, int x) {
        if (parent[x] == x) {
            return x;
        }
        return parent[x] = find(parent, parent[x]);
    }

    void _union(vector<int>& parent, vector<int>& size, int x, int y) {
        int rootX = find(parent, x);
        int rootY = find(parent, y);
        if (rootX == rootY) {
            return;
        }
        parent[rootY] = rootX;
        size[rootX] += size[rootY];
        size[rootY] = 0;
    }

    int minMalwareSpread(vector<vector<int>>& graph, vector<int>& initial) {
        int n = graph.size();
        vector<int> parent(n);
        vector<int> size(n);
        for (int i = 0; i < n; ++i) {
            parent[i] = i;
            size[i] = 1;
        }
        for (int i = 0; i < n; ++i) {
            for (int j = i + 1; j < n; ++j) {
                if (graph[i][j] == 1) {
                    _union(parent, size, i, j);
                }
            }
        }
        vector<int> initialCount(n);
        for (int i = 0; i < initial.size(); ++i) {
            initialCount[find(parent, initial[i])]++;
        }
        int ans = initial[0];
        int maxCount = 0;
        for (int i = 0; i < initial.size(); ++i) {
            int root = find(parent, initial[i]);
            if (initialCount[root] == 1) {
                if (size[root] > maxCount) {
                    maxCount = size[root];
                    ans = initial[i];
                }
                else if (size[root] == maxCount) {
                    ans = min(ans, initial[i]);
                }
            }
            else {
                if (initial[i] < ans) {
                    ans = initial[i];
                }
            }
        }
        return ans;
    }
};
// @lc code=end
