/*
 * @lc app=leetcode id=928 lang=cpp
 *
 * [928] Minimize Malware Spread II
 */

// @lc code=start
// 1. bfs
// 2024-01-16 submission
// 47/47 cases passed
// Runtime: 97 ms, faster than 70.45% of cpp online submissions.
// Memory Usage: 47.6 MB, less than 20.45% of cpp online submissions.
class Solution {
public:
    int minMalwareSpread(vector<vector<int>>& graph, vector<int>& initial) {
        int n = graph.size();
        vector<vector<int>> adj(n);
        for (int i = 0; i < n; ++i) {
            for (int j = i + 1; j < n; ++j) {
                if (graph[i][j]) {
                    adj[i].push_back(j);
                    adj[j].push_back(i);
                }
            }
        }
        int min_m = n + 1, res = -1;
        for (int i = 0; i < initial.size(); ++i) {
            int m = bfs(adj, initial, i);
            if (m < min_m) {
                min_m = m;
                res = initial[i];
            }
            else if (m == min_m) {
                res = min(res, initial[i]);
            }
        }
        return res;
    }

private:
    int bfs(vector<vector<int>>& adj, vector<int>& initial, int idx) {
        int n = adj.size();
        unordered_set<int> infected;
        queue<int> q;
        for (int i = 0; i < initial.size(); ++i) {
            if (i != idx) {
                infected.insert(initial[i]);
                q.push(initial[i]);
            }
        }
        while (!q.empty()) {
            int cur = q.front();
            q.pop();
            for (int next : adj[cur]) {
                if (infected.count(next) || next == initial[idx]) {
                    continue;
                }
                infected.insert(next);
                q.push(next);
            }
        }
        return infected.size();
    }
};
// @lc code=end

// @lc code=start
// 2. 并查集
// 2024-01-16 submission
// 47/47 cases passed
// Runtime: 86 ms, faster than 86.36% of cpp online submissions.
// Memory Usage: 42.8 MB, less than 59.85% of cpp online submissions.
class Solution {
public:
    int find(vector<int>& parent, int x) {
        if (parent[x] == x) {
            return x;
        }
        return parent[x] = find(parent, parent[x]);
    }

    void _union(vector<int>& parent, vector<int>& size, int x, int y) {
        int rootX = find(parent, x);
        int rootY = find(parent, y);
        if (rootX == rootY) {
            return;
        }
        parent[rootY] = rootX;
        size[rootX] += size[rootY];
        size[rootY] = 0;
    }

    int minMalwareSpread(vector<vector<int>>& graph, vector<int>& initial) {
        int n = graph.size();
        // build array of clean and infected nodes
        vector<bool> infected(n, false);
        for (int i = 0; i < initial.size(); ++i) {
            infected[initial[i]] = true;
        }
        // union find uninfected nodes
        vector<int> parent(n);
        vector<int> size(n);
        for (int i = 0; i < n; ++i) {
            parent[i] = i;
            size[i] = 1;
        }
        for (int i = 0; i < n; ++i) {
            if (infected[i]) {
                continue;
            }
            for (int j = i + 1; j < n; ++j) {
                if (infected[j] || graph[i][j] == 0) {
                    continue;
                }
                _union(parent, size, i, j);
            }
        }
        // count number of infected nodes in each component
        vector<int> infectedCount(n); // number of infected nodes in each component
        unordered_map<int, unordered_set<int>>
            infectedComponents; // infected components of each initial node
        for (int infectedNode : initial) {
            for (int i = 0; i < n; ++i) {
                if (infected[i] || graph[infectedNode][i] == 0) {
                    continue;
                }
                infectedComponents[infectedNode].insert(find(parent, i));
            }
            for (int component : infectedComponents[infectedNode]) {
                ++infectedCount[component];
            }
        }
        // find the initial node that can only infect one component and has the largest component
        // size
        int result = initial[0];
        int maxComponentSize = -1;
        for (int infectedNode : initial) {
            int componentSize = 0;
            for (int component : infectedComponents[infectedNode]) {
                if (infectedCount[component] == 1) {
                    componentSize += size[component];
                }
            }
            if (componentSize > maxComponentSize) {
                maxComponentSize = componentSize;
                result = infectedNode;
            }
            else if (componentSize == maxComponentSize) {
                result = min(result, infectedNode);
            }
        }
        return result;
    }
};
// @lc code=end
