# [923.3Sum With Multiplicity](https://leetcode.com/problems/3sum-with-multiplicity/description/)

## Description

**Tags**: math,binary-search,dynamic-programming

**Companies**: Unknown

|  Category  |   Difficulty    | Likes | Dislikes |
| :--------: | :-------------: | :---: | :------: |
| algorithms | Medium (45.27%) | 2543  |   301    |

<p>Given an integer array <code>arr</code>, and an integer <code>target</code>, return the number of tuples <code>i, j, k</code> such that <code>i &lt; j &lt; k</code> and <code>arr[i] + arr[j] + arr[k] == target</code>.</p>
<p>As the answer can be very large, return it <strong>modulo</strong> <code>10<sup>9</sup> + 7</code>.</p>
<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<pre><code><strong>Input:</strong> arr = [1,1,2,2,3,3,4,4,5,5], target = 8
<strong>Output:</strong> 20
<strong>Explanation: </strong>
Enumerating by the values (arr[i], arr[j], arr[k]):
(1, 2, 5) occurs 8 times;
(1, 3, 4) occurs 8 times;
(2, 2, 4) occurs 2 times;
(2, 3, 3) occurs 2 times.</code></pre>
<p><strong class="example">Example 2:</strong></p>
<pre><code><strong>Input:</strong> arr = [1,1,2,2,2,2], target = 5
<strong>Output:</strong> 12
<strong>Explanation: </strong>
arr[i] = 1, arr[j] = arr[k] = 2 occurs 12 times:
We choose one 1 from [1,1] in 2 ways,
and two 2s from [2,2,2,2] in 6 ways.</code></pre>
<p><strong class="example">Example 3:</strong></p>
<pre><code><strong>Input:</strong> arr = [2,1,3], target = 6
<strong>Output:</strong> 1
<strong>Explanation:</strong> (1, 2, 3) occured one time in the array so we return 1.</code></pre>
<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>
<ul>
  <li><code>3 &lt;= arr.length &lt;= 3000</code></li>
  <li><code>0 &lt;= arr[i] &lt;= 100</code></li>
  <li><code>0 &lt;= target &lt;= 300</code></li>
</ul>

## Solution

**题目描述**

给定一个整数数组 A，以及一个目标值 target，找到所有满足以下条件的三元组 (`A[i]`, `A[j]`, `A[k]`)的组合数量：

- `i < j < k`
- `A[i] + A[j] + A[k] == target`

**解题思路**

1. 排序+双指针
   - 首先对数组进行排序，然后使用双指针的方法，从左到右依次遍历数组，每次固定一个数，然后使用双指针的方法，找到剩下的两个数，使得三个数的和等于 target。
   - 由于存在重复的数字，还需要统计每个数字出现的次数，然后在双指针的过程中，需要跳过重复的数字。
   - 时间复杂度：O(N^2)，其中 N 是数组的长度。排序的时间复杂度是 O(NlogN)，双指针遍历的时间复杂度是 O(N^2)。
2. 动态规划
   - 状态定义：`dp[i][j][k]` 表示从数组的前 `i` 个数中选出 `k` 个数，使得这 `k` 个数的和等于 `j` 的组合数量，最后所要求的结果是 `dp[n][target][3]`
   - 状态初始化：`dp[i][0][0] = 1`
   - 状态转移方程：`dp[i][j][k] = dp[i - 1][j][k] + dp[i - 1][j - A[i - 1]][k - 1]`，因为 `A[i - 1]` 可以选也可以不选，所以 `dp[i][j][k]` 可以由 `dp[i - 1][j][k]` 和 `dp[i - 1][j - A[i - 1]][k - 1]` 转移得到。注意 `j - A[i - 1]` 不能小于 0，因为数组中的数字都是非负数
   - 更新顺序：由于 `dp[i][j][k]` 依赖于 `dp[i - 1][j][k]` 和 `dp[i - 1][j - A[i - 1]][k - 1]`，所以更新顺序应该是先遍历 `i`，再遍历 `j`，最后遍历 `k`，这样才能保证 `dp[i - 1][j][k]` 和 `dp[i - 1][j - A[i - 1]][k - 1]` 已经被计算过了
3. 哈希表
   - 首先使用哈希表统计每个数字出现的次数，然后遍历所有的数字对 `(i, j)`，检查 `k = target - i - j` 在哈希表中出现的次数
   - `i`、`j`、`k` 三者的大小关系需要分情况讨论
     - 如果 `i`、`j`、`k` 三者相等，那么组合的数量是 `count * (count - 1) * (count - 2) / 6`，其中 `count` 是数字 `i` 在数组中出现的次数
     - 如果 `i == j != k`，相当于在 `count(i)` 中选出两个数字，再从 `count(k)` 中选出一个数字，所以组合的数量是 `count(i) * (count(i) - 1) / 2 * count(k)`
     - 如果 `i != j != k`，那么组合的数量是 `count(i) * count(j) * count(k)`
   - 时间复杂度：O(N^2)，其中 N 是数组的长度。
4. 哈希表优化
   - 建立数组中任意两个数字之和的出现次数的映射，该数字之和出现了几次，就说明有多少个不同的两个数组合。
   - 遍历一次数组，对于每个数字，找到 `target - num` 出现的次数，累计到结果中即可。由于有新数字加入，此时需要更新哈希表。
   - 时间复杂度：O(N^2)，其中 N 是数组的长度。

**极端情况**

- [0,0,0], 0
