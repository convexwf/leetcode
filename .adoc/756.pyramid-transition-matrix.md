# [756.Pyramid Transition Matrix](https://leetcode.com/problems/pyramid-transition-matrix/description/)

## Description

**Tags**: array

**Companies**: Unknown

|  Category  |   Difficulty    | Likes | Dislikes |
| :--------: | :-------------: | :---: | :------: |
| algorithms | Medium (52.51%) |  508  |   467    |

<p>You are stacking blocks to form a pyramid. Each block has a color, which is represented by a single letter. Each row of blocks contains <strong>one less block</strong> than the row beneath it and is centered on top.</p>
<p>To make the pyramid aesthetically pleasing, there are only specific <strong>triangular patterns</strong> that are allowed. A triangular pattern consists of a <strong>single block</strong> stacked on top of <strong>two blocks</strong>. The patterns are given&nbsp;as a list of&nbsp;three-letter strings <code>allowed</code>, where the first two characters of a pattern represent the left and right bottom blocks respectively, and the third character is the top block.</p>
<ul>
  <li>For example, <code>&quot;ABC&quot;</code> represents a triangular pattern with a <code>&#39;C&#39;</code> block stacked on top of an <code>&#39;A&#39;</code> (left) and <code>&#39;B&#39;</code> (right) block. Note that this is different from <code>&quot;BAC&quot;</code> where <code>&#39;B&#39;</code> is on the left bottom and <code>&#39;A&#39;</code> is on the right bottom.</li>
</ul>
<p>You start with a bottom row of blocks <code>bottom</code>, given as a single string, that you <strong>must</strong> use as the base of the pyramid.</p>
<p>Given <code>bottom</code> and <code>allowed</code>, return <code>true</code><em> if you can build the pyramid all the way to the top such that <strong>every triangular pattern</strong> in the pyramid is in </em><code>allowed</code><em>, or </em><code>false</code><em> otherwise</em>.</p>
<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/08/26/pyramid1-grid.jpg" style="width: 600px; height: 232px;" />
<pre><code><strong>Input:</strong> bottom = &quot;BCD&quot;, allowed = [&quot;BCC&quot;,&quot;CDE&quot;,&quot;CEA&quot;,&quot;FFF&quot;]
<strong>Output:</strong> true
<strong>Explanation:</strong> The allowed triangular patterns are shown on the right.
Starting from the bottom (level 3), we can build &quot;CE&quot; on level 2 and then build &quot;A&quot; on level 1.
There are three triangular patterns in the pyramid, which are &quot;BCC&quot;, &quot;CDE&quot;, and &quot;CEA&quot;. All are allowed.</code></pre>
<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/08/26/pyramid2-grid.jpg" style="width: 600px; height: 359px;" />
<pre><code><strong>Input:</strong> bottom = &quot;AAAA&quot;, allowed = [&quot;AAB&quot;,&quot;AAC&quot;,&quot;BCD&quot;,&quot;BBE&quot;,&quot;DEF&quot;]
<strong>Output:</strong> false
<strong>Explanation:</strong> The allowed triangular patterns are shown on the right.
Starting from the bottom (level 4), there are multiple ways to build level 3, but trying all the possibilites, you will get always stuck before building level 1.</code></pre>
<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>
<ul>
  <li><code>2 &lt;= bottom.length &lt;= 6</code></li>
  <li><code>0 &lt;= allowed.length &lt;= 216</code></li>
  <li><code>allowed[i].length == 3</code></li>
  <li>The letters in all input strings are from the set <code>{&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;, &#39;E&#39;, &#39;F&#39;}</code>.</li>
  <li>All the values of <code>allowed</code> are <strong>unique</strong>.</li>
</ul>

## Solution

**题目描述**

把积木堆成金字塔。每个块都有一个颜色，用一个字母表示。每一行的块比它下面的行 少一个块 ，并且居中。

为了使金字塔美观，只有特定的 三角形图案 是允许的。一个三角形的图案由 两个块 和叠在上面的 单个块 组成。模式是以三个字母字符串的列表形式 allowed 给出的，其中模式的前两个字符分别表示左右底部块，第三个字符表示顶部块。

从底部的一排积木 bottom 开始，如果你能一直构建到金字塔顶部，使金字塔中的 每个三角形图案 都是允许的，则返回 true ，否则返回 false 。

**解题思路**

1. 递归回溯
   - 首先将 `allowed` 转换成哈希表，方便查找
   - 然后递归回溯，每次从 `bottom` 的第 `i` 个位置开始，找到所有可能的下一层的块，组成一个新的 `bottom`，放入 `next` 中，然后递归下一层
   - 如果递归到最后一层，说明可以构成金字塔，返回 `True`，否则返回 `False`
   - 时间复杂度 $O(3^n)$，空间复杂度 $O(n)$
2. 动态规划+位运算
   - 首先将 `allowed` 转换成哈希表，key 为第三个字符，value 为前两个字符的拼接集合
   - 建立一个二维的 `dp` 数组，`dp[i][j]` 表示第 `i` 行，第 `j` 个位置可以放置块。因为题意限制 块 字母为 `A-F`，所以可以用一个二进制数表示，第 `i` 位为 `1` 表示可以放置第 `i` 个块，否则为 `0`。例如 `dp[0][0] = 0b000101 = 5`，表示第一行第一个位置可以放置 `A` 和 `C`。
   - 从第 0 行开始，从左到右，从上到下，依次判断是否可以放置块，状态转移方程为 `dp[i][j] = dp[i][j] | (dp[i+1][j] & dp[i+1][j+1])`，即当前位置可以放置的块为下一层两个位置可以放置的块的交集。
   - 最后判断 `dp[n-1][0]` 是否大于 `0`，如果大于 `0`，说明可以构成金字塔，返回 `True`，否则返回 `False`
   - 时间复杂度 $O(n^2)$，空间复杂度 $O(n^2)$
