# [955.Delete Columns to Make Sorted II](https://leetcode.com/problems/delete-columns-to-make-sorted-ii/description/)

## Description

**Tags**: tree

**Companies**: Unknown

|  Category  |   Difficulty    | Likes | Dislikes |
| :--------: | :-------------: | :---: | :------: |
| algorithms | Medium (34.98%) |  639  |    86    |

<p>You are given an array of <code>n</code> strings <code>strs</code>, all of the same length.</p>
<p>We may choose any deletion indices, and we delete all the characters in those indices for each string.</p>
<p>For example, if we have <code>strs = [&quot;abcdef&quot;,&quot;uvwxyz&quot;]</code> and deletion indices <code>{0, 2, 3}</code>, then the final array after deletions is <code>[&quot;bef&quot;, &quot;vyz&quot;]</code>.</p>
<p>Suppose we chose a set of deletion indices <code>answer</code> such that after deletions, the final array has its elements in <strong>lexicographic</strong> order (i.e., <code>strs[0] &lt;= strs[1] &lt;= strs[2] &lt;= ... &lt;= strs[n - 1]</code>). Return <em>the minimum possible value of</em> <code>answer.length</code>.</p>
<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<pre><code><strong>Input:</strong> strs = [&quot;ca&quot;,&quot;bb&quot;,&quot;ac&quot;]
<strong>Output:</strong> 1
<strong>Explanation:</strong>
After deleting the first column, strs = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;].
Now strs is in lexicographic order (ie. strs[0] &lt;= strs[1] &lt;= strs[2]).
We require at least 1 deletion since initially strs was not in lexicographic order, so the answer is 1.</code></pre>
<p><strong class="example">Example 2:</strong></p>
<pre><code><strong>Input:</strong> strs = [&quot;xc&quot;,&quot;yb&quot;,&quot;za&quot;]
<strong>Output:</strong> 0
<strong>Explanation:</strong>
strs is already in lexicographic order, so we do not need to delete anything.
Note that the rows of strs are not necessarily in lexicographic order:
i.e., it is NOT necessarily true that (strs[0][0] &lt;= strs[0][1] &lt;= ...)</code></pre>
<p><strong class="example">Example 3:</strong></p>
<pre><code><strong>Input:</strong> strs = [&quot;zyx&quot;,&quot;wvu&quot;,&quot;tsr&quot;]
<strong>Output:</strong> 3
<strong>Explanation:</strong> We have to delete every column.</code></pre>
<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>
<ul>
  <li><code>n == strs.length</code></li>
  <li><code>1 &lt;= n &lt;= 100</code></li>
  <li><code>1 &lt;= strs[i].length &lt;= 100</code></li>
  <li><code>strs[i]</code> consists of lowercase English letters.</li>
</ul>

## Solution

**题目描述**

给定一个字符串数组 `strs`，删除一些列，使得剩余的字符串数组按照字典序递增排序。返回最少需要删除的列数。

这里的删除列是指删除所有字符串中的某一列，例如：

```txt
["abcdef", "uvwxyz"]

可以写作

abcdef
uvwxyz

删除第 0 列后，剩余字符串数组为

bcdef
vwxyz
```

**解题思路**

1. 贪心算法
   - 从左到右遍历每一列，如果当前列不满足字典序递增，则删除当前列
   - 如果当前列已经满足字典序递增，直接结束遍历，因为后面的列不会影响当前列的字典序，即字符串数组已经满足字典序递增
   - 时间复杂度：$O(nm)$，其中 $n$ 为字符串数组的长度，$m$ 为字符串的长度

```cpp
class Solution {
public:
    int minDeletionSize(vector<string>& strs) {
        int m = strs.size(), n = strs[0].size();
        int ans = 0;
        for (int j = 0; j < n; ++j) {
            int i = 1;
            for (; i < m; ++i) {
                if (strs[i][j] < strs[i - 1][j]) {
                    ++ans;
                    break;
                }
            }
            if (i == m) {
                break;
            }
        }
        return ans;
    }
};
```
```
