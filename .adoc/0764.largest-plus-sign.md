# [764.Largest Plus Sign](https://leetcode.com/problems/largest-plus-sign/description/)

## Description

**Tags**: tree,breadth-first-search

**Companies**: Unknown

|  Category  |   Difficulty    | Likes | Dislikes |
| :--------: | :-------------: | :---: | :------: |
| algorithms | Medium (48.20%) | 1347  |   215    |

<p>You are given an integer <code>n</code>. You have an <code>n x n</code> binary grid <code>grid</code> with all values initially <code>1</code>&#39;s except for some indices given in the array <code>mines</code>. The <code>i<sup>th</sup></code> element of the array <code>mines</code> is defined as <code>mines[i] = [x<sub>i</sub>, y<sub>i</sub>]</code> where <code>grid[x<sub>i</sub>][y<sub>i</sub>] == 0</code>.</p>
<p>Return <em>the order of the largest <strong>axis-aligned</strong> plus sign of </em>1<em>&#39;s contained in </em><code>grid</code>. If there is none, return <code>0</code>.</p>
<p>An <strong>axis-aligned plus sign</strong> of <code>1</code>&#39;s of order <code>k</code> has some center <code>grid[r][c] == 1</code> along with four arms of length <code>k - 1</code> going up, down, left, and right, and made of <code>1</code>&#39;s. Note that there could be <code>0</code>&#39;s or <code>1</code>&#39;s beyond the arms of the plus sign, only the relevant area of the plus sign is checked for <code>1</code>&#39;s.</p>
<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/06/13/plus1-grid.jpg" style="width: 404px; height: 405px;" />
<pre><code><strong>Input:</strong> n = 5, mines = [[4,2]]
<strong>Output:</strong> 2
<strong>Explanation:</strong> In the above grid, the largest plus sign can only be of order 2. One of them is shown.</code></pre>
<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/06/13/plus2-grid.jpg" style="width: 84px; height: 85px;" />
<pre><code><strong>Input:</strong> n = 1, mines = [[0,0]]
<strong>Output:</strong> 0
<strong>Explanation:</strong> There is no plus sign, so return 0.</code></pre>
<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>
<ul>
  <li><code>1 &lt;= n &lt;= 500</code></li>
  <li><code>1 &lt;= mines.length &lt;= 5000</code></li>
  <li><code>0 &lt;= x<sub>i</sub>, y<sub>i</sub> &lt; n</code></li>
  <li>All the pairs <code>(x<sub>i</sub>, y<sub>i</sub>)</code> are <strong>unique</strong>.</li>
</ul>

## Solution

**题目描述**

给定一个大小为 $n x n$ 的矩阵 grid，其中 `grid[i][j]` 为 0 或 1，找出最大的十字形形状的 1 的数量，并返回该数量。如果该形状不存在，则返回 0。

**解题思路**

1. 动态规划
   - 针对每个点，分别计算其上下左右连续的 1 的个数，然后取最小值，即为该点所在十字形状的 1 的个数。
   - 定义四个二维数组 left、right、up 和 down，用于记录每个格子左侧、右侧、上方和下方相连的连续 1 的个数。然后遍历每个格子，计算以当前格子为中心的十字的长度。
   - 时间复杂度：$O(n^2)$，空间复杂度：$O(n^2)$
2. 动态规划+空间优化
   - 原理同 1，实际上可以利用一个二维数组 dp 存储扩展过程中最小臂的长度。
   - 时间复杂度：$O(n^2)$，空间复杂度：$O(n^2)$
