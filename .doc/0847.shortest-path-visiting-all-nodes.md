# [847.Shortest Path Visiting All Nodes](https://leetcode.com/problems/shortest-path-visiting-all-nodes/description/)

## Description

**Tags**: Unknown

**Companies**: Unknown

|  Category  |  Difficulty   | Likes | Dislikes |
| :--------: | :-----------: | :---: | :------: |
| algorithms | Hard (65.39%) | 4321  |   170    |

<p>You have an undirected, connected graph of <code>n</code> nodes labeled from <code>0</code> to <code>n - 1</code>. You are given an array <code>graph</code> where <code>graph[i]</code> is a list of all the nodes connected with node <code>i</code> by an edge.</p>
<p>Return <em>the length of the shortest path that visits every node</em>. You may start and stop at any node, you may revisit nodes multiple times, and you may reuse edges.</p>
<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/05/12/shortest1-graph.jpg" style="width: 222px; height: 183px;" />
<pre><code><strong>Input:</strong> graph = [[1,2,3],[0],[0],[0]]
<strong>Output:</strong> 4
<strong>Explanation:</strong> One possible path is [1,0,2,0,3]</code></pre>
<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/05/12/shortest2-graph.jpg" style="width: 382px; height: 222px;" />
<pre><code><strong>Input:</strong> graph = [[1],[0,2,4],[1,3,4],[2],[1,2]]
<strong>Output:</strong> 4
<strong>Explanation:</strong> One possible path is [0,1,4,2,3]</code></pre>
<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>
<ul>
  <li><code>n == graph.length</code></li>
  <li><code>1 &lt;= n &lt;= 12</code></li>
  <li><code>0 &lt;= graph[i].length &lt;&nbsp;n</code></li>
  <li><code>graph[i]</code> does not contain <code>i</code>.</li>
  <li>If <code>graph[a]</code> contains <code>b</code>, then <code>graph[b]</code> contains <code>a</code>.</li>
  <li>The input graph is always connected.</li>
</ul>

## Solution

**题目描述**

给定一个由 `n` 个节点组成的无向连通图，按照从 `0` 到 `n - 1` 对这些节点进行编号。另给定一个数组 `graph`，其中 `graph[i]` 是与节点 `i` 相连的所有节点。

返回能够访问所有节点的最短路径的长度。你可以在任意节点开始和停止，可以多次经过同一个节点，可以重用边。

**解题思路**

1. bfs+位操作+状态压缩
   - 最终状态要求遍历所有节点，节点数量小于 12，因为可以用一个整数的二进制位来表示节点的访问状态。比如 `n = 4` 时，`0000` 表示没有访问任何节点，`1111` 表示访问了所有节点。
   - 使用队列进行广度优先搜索，初始将所有节点和对应的状态压缩成一个元组 `(0, 1 << i)`，其中 `i` 是当前节点的编号，`1 << i` 表示将第 `i` 位设置为 1，表示访问了节点 `i`。
   - 每一轮循环中，将当前队列中的所有元素出队
     - 对于每个出队的元素 `(node, state)`，如果 `state` 等于 `(1 << n) - 1`，表示所有节点都已访问，返回当前路径长度。
     - 遍历当前节点 `node` 的所有相邻节点 `next_node`，因为节点可以被多次访问，更新状态为 `next_state = state | (1 << next_node)`，将 `(next_node, next_state)` 入队。
     - 为了防止重复访问相同的状态，使用一个哈希集合 `visited` 来记录已经访问过的状态，此处的状态编码为 `next_node` 和 `next_state` 的拼接字符串。
   - 时间复杂度为 $O(n^2 * 2^n)$，其中 $n$ 是节点数量。由于 $n$ 的最大值为 12，因此可以接受。空间复杂度为 $O(n * 2^n)$，用于存储队列和访问状态。
2. bfs+状态压缩+最小堆
   - 使用最小堆来优化 bfs 的搜索过程，优先访问距离较短的节点。
   - 将每个节点和对应的状态压缩成一个元组 `(dist, node, state)`，其中 `dist` 是当前路径长度，`node` 是当前节点，`state` 是访问状态。
     - 访问状态使用整数的二进制位来表示，`state` 的第 `i` 位为 1 表示访问了节点 `i`。
   - 初始将所有节点和对应的状态压缩成一个元组 `(0, i, 1 << i)`，其中 `i` 是当前节点的编号，`1 << i` 表示将第 `i` 位设置为 1，表示访问了节点 `i`。
   - 每一轮循环中，将当前最小堆中的元素出堆
     - 对于每个出堆的元素 `(dist, node, state)`，如果 `state` 等于 `(1 << n) - 1`，表示所有节点都已访问，返回当前路径长度。
     - 遍历当前节点 `node` 的所有相邻节点 `next_node`，如果 `state | (1 << next_node)` 没有被访问过，则将其入堆。
     - 使用一个哈希集合 `seen` 来记录已经访问过的状态，防止重复访问。
   - 时间复杂度为 $O(n^2 * 2^n \log(2^n))$，其中 $n$ 是节点数量。由于 $n$ 的最大值为 12，因此可以接受。空间复杂度为 $O(n * 2^n)$，用于存储最小堆和访问状态。

**标签**

- bit-manipulation
- breadth-first-search
- heap
- hash-table
