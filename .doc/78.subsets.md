# [Subsets](https://leetcode.com/problems/subsets/description/)

## Description

**tags**: array,backtracking,bit-manipulation
**companies**: amazon,bloomberg,facebook,uber

|  Category  |   Difficulty    | Likes | Dislikes |
| :--------: | :-------------: | :---: | :------: |
| algorithms | Medium (72.55%) | 11004 |   165    |

<p>Given an integer array <code>nums</code> of <strong>unique</strong> elements, return <em>all possible subsets (the power set)</em>.</p>

<p>The solution set <strong>must not</strong> contain duplicate subsets. Return the solution in <strong>any order</strong>.</p>

<p>&nbsp;</p>
<p><strong>Example 1:</strong></p>

<pre><code><strong>Input:</strong> nums = [1,2,3]
<strong>Output:</strong> [[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]</code></pre>

<p><strong>Example 2:</strong></p>

<pre><code><strong>Input:</strong> nums = [0]
<strong>Output:</strong> [[],[0]]</code></pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
  <li><code>1 &lt;= nums.length &lt;= 10</code></li>
  <li><code>-10 &lt;= nums[i] &lt;= 10</code></li>
  <li>All the numbers of&nbsp;<code>nums</code> are <strong>unique</strong>.</li>
</ul>

## Solution

**题目描述**: 找出给定集合的所有子集，输入数组没有重复项。

**解题思路**:

以 [1,2,3] 为例

1. 非递归遍历: 按照子集的长度由少到多全部写出来，添加顺序为 [], [1], [2], [1 2], [3], [1 3], [2 3], [1 2 3]
2. DFS 深度优先搜索: 原集合每一个数字只有两种状态，要么存在，要么不存在，那么在构造子集时就有选择和不选择两种情况
3. 位操作：数组中所有的数分配一个状态，true 表示这个数在子集中出现，false 表示在子集中不出现，那么对于一个长度为n的数组，每个数字都有出现与不出现两种情况，所以共有 $2^n$ 种情况。

    | **集合** | **整数** | **A是否出现** | **B是否出现** | **C是否出现** |
    | -------- | -------- | ------------- | ------------- | ------------- |
    | {}       | 000=0    | 100&000=0     | 010&000=0     | 001&000=0     |
    | {C}      | 001=1    | 100&001=0     | 010&001=0     | 001&001=1     |
    | {B}      | 010=2    | 100&010=0     | 010&010=1     | 001&010=0     |
    | {B,C}    | 011=3    | 100&011=0     | 010&011=1     | 001&011=1     |
    | {A}      | 100=4    | 100&100=1     | 010&100=0     | 001&100=0     |
    | {A,C}    | 101=5    | 100&101=1     | 010&101=0     | 001&101=1     |
    | {A,B}    | 110=6    | 100&110=1     | 010&110=1     | 001&110=0     |
    | {A,B,C}  | 111=7    | 100&111=1     | 010&111=1     | 001&111=1     |

**关联专题**: undefined

## Code

```cpp
// 2022-07-26 submission
// 10/10 cases passed
// Runtime: 7 ms, faster than 34.37% of C++ online submissions.
// Memory Usage: 7.1 MB, less than 70.41% of C++ online submissions.
class Solution {
public:
    vector<vector<int>> subsets(vector<int>& nums) {
        vector<vector<int>> res(1);
        for (int i = 0; i < nums.size(); ++i) {
            int n = res.size();
            for (int j = 0; j < n; ++j) {
                res.push_back(res[j]);
                res.back().push_back(nums[i]);
            }
        }
        return res;
    }
};
```

```cpp
// 2022-07-26 submission
// 10/10 cases passed
// Runtime: 6 ms, faster than 39.17% of C++ online submissions.
// Memory Usage: 7.1 MB, less than 70.41% of C++ online submissions.
class Solution {
public:
    vector<vector<int>> subsets(vector<int>& nums) {
        vector<vector<int>> result;
        vector<int> temp;
        DFS(nums, temp, result, 0);
        return result;
    }

    void DFS(vector<int>& candidates, vector<int>& curr, vector<vector<int>>& result, int pivot) {
        result.push_back(curr);
        for(int i = pivot; i < candidates.size(); i++) {
            curr.push_back(candidates[i]);
            DFS(candidates, curr, result, i+1);
            curr.pop_back();
        }
    }
};
```

```cpp
// 2022-07-26 submission
// 10/10 cases passed
// Runtime: 5 ms, faster than 43.24% of C++ online submissions.
// Memory Usage: 7.2 MB, less than 70.41% of C++ online submissions.
class Solution {
public:
    vector<vector<int>> subsets(vector<int>& nums) {
        vector<vector<int>> res;
        int count = 1 << nums.size();
        for (int i = 0; i < count; i++) {
            vector<int> vec;
            for (int j = 0; j < nums.size(); j++) {
                if (i & (1 << j)) vec.push_back(nums[j]);
            }
            res.push_back(vec);
        }
        return res;
    }
};
```
