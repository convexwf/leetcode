# [928.Minimize Malware Spread II](https://leetcode.com/problems/minimize-malware-spread-ii/description/)

## Description

**Tags**: math,geometry

**Companies**: Unknown

|  Category  |  Difficulty   | Likes | Dislikes |
| :--------: | :-----------: | :---: | :------: |
| algorithms | Hard (42.97%) |  643  |    88    |

<p>You are given a network of <code>n</code> nodes represented as an <code>n x n</code> adjacency matrix <code>graph</code>, where the <code>i<sup>th</sup></code> node is directly connected to the <code>j<sup>th</sup></code> node if <code>graph[i][j] == 1</code>.</p>
<p>Some nodes <code>initial</code> are initially infected by malware. Whenever two nodes are directly connected, and at least one of those two nodes is infected by malware, both nodes will be infected by malware. This spread of malware will continue until no more nodes can be infected in this manner.</p>
<p>Suppose <code>M(initial)</code> is the final number of nodes infected with malware in the entire network after the spread of malware stops.</p>
<p>We will remove <strong>exactly one node</strong> from <code>initial</code>, <strong>completely removing it and any connections from this node to any other node</strong>.</p>
<p>Return the node that, if removed, would minimize <code>M(initial)</code>. If multiple nodes could be removed to minimize <code>M(initial)</code>, return such a node with <strong>the smallest index</strong>.</p>
<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<pre><code><strong>Input:</strong> graph = [[1,1,0],[1,1,0],[0,0,1]], initial = [0,1]
<strong>Output:</strong> 0</code></pre><p><strong class="example">Example 2:</strong></p>
<pre><code><strong>Input:</strong> graph = [[1,1,0],[1,1,1],[0,1,1]], initial = [0,1]
<strong>Output:</strong> 1</code></pre><p><strong class="example">Example 3:</strong></p>
<pre><code><strong>Input:</strong> graph = [[1,1,0,0],[1,1,1,0],[0,1,1,1],[0,0,1,1]], initial = [0,1]
<strong>Output:</strong> 1</code></pre>
<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>
<ul>
  <li><code>n == graph.length</code></li>
  <li><code>n == graph[i].length</code></li>
  <li><code>2 &lt;= n &lt;= 300</code></li>
  <li><code>graph[i][j]</code> is <code>0</code> or <code>1</code>.</li>
  <li><code>graph[i][j] == graph[j][i]</code></li>
  <li><code>graph[i][i] == 1</code></li>
  <li><code>1 &lt;= initial.length &lt;&nbsp;n</code></li>
  <li><code>0 &lt;= initial[i] &lt;= n - 1</code></li>
  <li>All the integers in <code>initial</code> are <strong>unique</strong>.</li>
</ul>

## Solution

**题目描述**

给定一个用邻接矩阵表示的图，其中一些节点 `initial` 最初被感染了病毒。只要两个节点直接连接，且其中至少一个节点受到病毒影响，那么两个节点都将被感染。这种病毒的传播会持续进行，直到没有更多的节点可以被这种方式感染。

假设 `M(initial)` 表示在病毒停止传播之后，整个图区域中感染病毒的节点数。如果从初始点列表 `initial` 中去除一个节点，使将其与任何其他节点分开，如果这种情况下最终得到的 `M(initial)` 最小，返回该节点。如果有多个节点满足条件，返回索引最小的节点。

本题与 [0924.Minimize Malware Spread](0924.minimize-malware-spread.md) 类似，不同之处在于，本题是完全剔除一个节点，而不是将其标记为未感染。

**解题思路**

1. BFS
   - 遍历 `initial` 中的每个节点，假设去掉该节点后，使用 BFS 模拟病毒传播，得到最终感染的节点数 `M(initial)`，记录下来。
   - BFS 过程中，初始时将所有感染的节点入队，然后依次出队，将与出队节点相连的未感染节点入队，直到队列为空，最后返回感染的节点数。如果遇到去掉的节点，那么就不再继续传播。
   - 为了加速查找邻接节点的过程，可以将邻接矩阵转换为邻接表
   - 时间复杂度：$O(n^2)$ ，空间复杂度：$O(n)$
2. 并查集
   - 可以认为是感染节点将图分割成了若干个连通分量，每个连通分量只由未感染的节点组成。那么每个感染节点都会感染一个或多个连通分量，一个连通分量也会被一个或多个感染节点感染。
   - 进一步地，如果一个连通分量中同时连接两个以上的感染节点，那么去除其中一个感染节点，该连通分量仍然会被感染。如果一个连通分量中只连接一个感染节点，那么去除该感染节点，该连通分量不会被感染。所以只需要计算只会被一个感染节点感染的连通分量的节点数，然后选择节点数最多的那个连通分量中的感染节点。
   - 遍历所有未感染的节点，即不在 `initial` 中的节点，构造并查集，并且统计每个连通分量中的节点数。
   - 然后找到所有只被一个感染节点感染的连通分量，统计其中的节点数，选择节点数最多的那个连通分量中的感染节点。
   - 时间复杂度：$O(n^2)$ ，空间复杂度：$O(n)$

**标签**

- union-find
- graph
- breadth-first-search

<!-- code start -->
## Code

### C++

```cpp
// 1. bfs
// 2024-01-16 submission
// 47/47 cases passed
// Runtime: 97 ms, faster than 70.45% of cpp online submissions.
// Memory Usage: 47.6 MB, less than 20.45% of cpp online submissions.
class Solution {
public:
    int minMalwareSpread(vector<vector<int>>& graph, vector<int>& initial) {
        int n = graph.size();
        vector<vector<int>> adj(n);
        for (int i = 0; i < n; ++i) {
            for (int j = i + 1; j < n; ++j) {
                if (graph[i][j]) {
                    adj[i].push_back(j);
                    adj[j].push_back(i);
                }
            }
        }
        int min_m = n + 1, res = -1;
        for (int i = 0; i < initial.size(); ++i) {
            int m = bfs(adj, initial, i);
            if (m < min_m) {
                min_m = m;
                res = initial[i];
            }
            else if (m == min_m) {
                res = min(res, initial[i]);
            }
        }
        return res;
    }

private:
    int bfs(vector<vector<int>>& adj, vector<int>& initial, int idx) {
        int n = adj.size();
        unordered_set<int> infected;
        queue<int> q;
        for (int i = 0; i < initial.size(); ++i) {
            if (i != idx) {
                infected.insert(initial[i]);
                q.push(initial[i]);
            }
        }
        while (!q.empty()) {
            int cur = q.front();
            q.pop();
            for (int next : adj[cur]) {
                if (infected.count(next) || next == initial[idx]) {
                    continue;
                }
                infected.insert(next);
                q.push(next);
            }
        }
        return infected.size();
    }
};
```

```cpp
// 2. 并查集
// 2024-01-16 submission
// 47/47 cases passed
// Runtime: 86 ms, faster than 86.36% of cpp online submissions.
// Memory Usage: 42.8 MB, less than 59.85% of cpp online submissions.
class Solution {
public:
    int find(vector<int>& parent, int x) {
        if (parent[x] == x) {
            return x;
        }
        return parent[x] = find(parent, parent[x]);
    }

    void _union(vector<int>& parent, vector<int>& size, int x, int y) {
        int rootX = find(parent, x);
        int rootY = find(parent, y);
        if (rootX == rootY) {
            return;
        }
        parent[rootY] = rootX;
        size[rootX] += size[rootY];
        size[rootY] = 0;
    }

    int minMalwareSpread(vector<vector<int>>& graph, vector<int>& initial) {
        int n = graph.size();
        // build array of clean and infected nodes
        vector<bool> infected(n, false);
        for (int i = 0; i < initial.size(); ++i) {
            infected[initial[i]] = true;
        }
        // union find uninfected nodes
        vector<int> parent(n);
        vector<int> size(n);
        for (int i = 0; i < n; ++i) {
            parent[i] = i;
            size[i] = 1;
        }
        for (int i = 0; i < n; ++i) {
            if (infected[i]) {
                continue;
            }
            for (int j = i + 1; j < n; ++j) {
                if (infected[j] || graph[i][j] == 0) {
                    continue;
                }
                _union(parent, size, i, j);
            }
        }
        // count number of infected nodes in each component
        vector<int> infectedCount(n); // number of infected nodes in each component
        unordered_map<int, unordered_set<int>>
            infectedComponents; // infected components of each initial node
        for (int infectedNode : initial) {
            for (int i = 0; i < n; ++i) {
                if (infected[i] || graph[infectedNode][i] == 0) {
                    continue;
                }
                infectedComponents[infectedNode].insert(find(parent, i));
            }
            for (int component : infectedComponents[infectedNode]) {
                ++infectedCount[component];
            }
        }
        // find the initial node that can only infect one component and has the largest component
        // size
        int result = initial[0];
        int maxComponentSize = -1;
        for (int infectedNode : initial) {
            int componentSize = 0;
            for (int component : infectedComponents[infectedNode]) {
                if (infectedCount[component] == 1) {
                    componentSize += size[component];
                }
            }
            if (componentSize > maxComponentSize) {
                maxComponentSize = componentSize;
                result = infectedNode;
            }
            else if (componentSize == maxComponentSize) {
                result = min(result, infectedNode);
            }
        }
        return result;
    }
};
```

<!-- code end -->
