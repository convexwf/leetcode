# [Next Greater Element III](https://leetcode.com/problems/next-greater-element-iii/description/)

## Description

**tags**: string
**companies**: bloomberg

|  Category  |   Difficulty    | Likes | Dislikes |
| :--------: | :-------------: | :---: | :------: |
| algorithms | Medium (34.02%) | 2620  |   370    |

<p>Given a positive integer <code>n</code>, find <em>the smallest integer which has exactly the same digits existing in the integer</em> <code>n</code> <em>and is greater in value than</em> <code>n</code>. If no such positive integer exists, return <code>-1</code>.</p>

<p><strong>Note</strong> that the returned integer should fit in <strong>32-bit integer</strong>, if there is a valid answer but it does not fit in <strong>32-bit integer</strong>, return <code>-1</code>.</p>

<p>&nbsp;</p>
<p><strong>Example 1:</strong></p>
<pre><code><strong>Input:</strong> n = 12
<strong>Output:</strong> 21</code></pre><p><strong>Example 2:</strong></p>
<pre><code><strong>Input:</strong> n = 21
<strong>Output:</strong> -1</code></pre>
<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
  <li><code>1 &lt;= n &lt;= 2<sup>31</sup> - 1</code></li>
</ul>

## Solution

**题目描述**: 对给定数字的各个位数重新排序，求刚好比给定数字大的一种排序，如果不存在就返回-1。

**解题思路**

1. 参见 <31. Next Permutation>

**边界条件**

1. 转换后的数字可能会越界
2. 输入 n 已经是最大值，没有下一个较大的数字

**关联专题**: undefined

## Code

```cpp
// 2022-08-26 submission
// 39/39 cases passed
// Runtime: 0 ms, faster than 100% of C++ online submissions.
// Memory Usage: 5.9 MB, less than 93.88% of C++ online submissions.
class Solution {
public:
    int nextGreaterElement(int n) {
        string str = to_string(n);
        int len = str.size(), i = len - 2, j = len - 1;
        while (i >= 0 && str[i] >= str[i + 1]) --i;
        if (i < 0) return -1;
        while (str[j] <= str[i]) --j;
        swap(str[i], str[j]);
        reverse(str.begin() + i + 1, str.end());
        long long res = stoll(str);
        return res > INT_MAX ? -1 : res;
    }
};
```
