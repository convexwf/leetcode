# [Walking Robot Simulation](https://leetcode.com/problems/walking-robot-simulation/description/)

## Description

**tags**: two-pointers,stack
**companies**: Unknown

|  Category  |   Difficulty    | Likes | Dislikes |
| :--------: | :-------------: | :---: | :------: |
| algorithms | Medium (38.74%) |  147  |    23    |

<p>A robot on an infinite XY-plane starts at point <code>(0, 0)</code> facing north. The robot can receive a sequence of these three possible types of <code>commands</code>:</p>

<ul>
  <li><code>-2</code>: Turn left <code>90</code> degrees.</li>
  <li><code>-1</code>: Turn right <code>90</code> degrees.</li>
  <li><code>1 &lt;= k &lt;= 9</code>: Move forward <code>k</code> units, one unit at a time.</li>
</ul>

<p>Some of the grid squares are <code>obstacles</code>. The <code>i<sup>th</sup></code> obstacle is at grid point <code>obstacles[i] = (x<sub>i</sub>, y<sub>i</sub>)</code>. If the robot runs into an obstacle, then it will instead stay in its current location and move on to the next command.</p>

<p>Return <em>the <strong>maximum Euclidean distance</strong> that the robot ever gets from the origin <strong>squared</strong> (i.e. if the distance is </em><code>5</code><em>, return </em><code>25</code><em>)</em>.</p>

<p><strong>Note:</strong></p>

<ul>
  <li>North means +Y direction.</li>
  <li>East means +X direction.</li>
  <li>South means -Y direction.</li>
  <li>West means -X direction.</li>
</ul>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre><code><strong>Input:</strong> commands = [4,-1,3], obstacles = []
<strong>Output:</strong> 25
<strong>Explanation:</strong> The robot starts at (0, 0):
1. Move north 4 units to (0, 4).
2. Turn right.
3. Move east 3 units to (3, 4).
The furthest point the robot ever gets from the origin is (3, 4), which squared is 3<sup>2</sup> + 4<sup>2</sup> = 25 units away.</code></pre>

<p><strong class="example">Example 2:</strong></p>

<pre><code><strong>Input:</strong> commands = [4,-1,4,-2,4], obstacles = [[2,4]]
<strong>Output:</strong> 65
<strong>Explanation:</strong> The robot starts at (0, 0):
1. Move north 4 units to (0, 4).
2. Turn right.
3. Move east 1 unit and get blocked by the obstacle at (2, 4), robot is at (1, 4).
4. Turn left.
5. Move north 4 units to (1, 8).
The furthest point the robot ever gets from the origin is (1, 8), which squared is 1<sup>2</sup> + 8<sup>2</sup> = 65 units away.</code></pre>

<p><strong class="example">Example 3:</strong></p>

<pre><code><strong>Input:</strong> commands = [6,-1,-1,6], obstacles = []
<strong>Output:</strong> 36
<strong>Explanation:</strong> The robot starts at (0, 0):
1. Move north 6 units to (0, 6).
2. Turn right.
3. Turn right.
4. Move south 6 units to (0, 0).
The furthest point the robot ever gets from the origin is (0, 6), which squared is 6<sup>2</sup> = 36 units away.</code></pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
  <li><code>1 &lt;= commands.length &lt;= 10<sup>4</sup></code></li>
  <li><code>commands[i]</code> is either <code>-2</code>, <code>-1</code>, or an integer in the range <code>[1, 9]</code>.</li>
  <li><code>0 &lt;= obstacles.length &lt;= 10<sup>4</sup></code></li>
  <li><code>-3 * 10<sup>4</sup> &lt;= x<sub>i</sub>, y<sub>i</sub> &lt;= 3 * 10<sup>4</sup></code></li>
  <li>The answer is guaranteed to be less than <code>2<sup>31</sup></code>.</li>
</ul>

## Solution

**题目描述**: 机器人在一个无限大小的 XY 网格平面上行走，从点 (0, 0) 处开始出发，面向北方。该机器人可以接收以下三种类型的命令 commands：(1) -2:向左转 90 度；(2) -1:向右转 90 度；(3) 1 <= x <= 9 ：向前移动 x 个单位长度。在网格上有一些格子被视为障碍物 obstacles。第 i 个障碍物位于网格点 obstacles[i] = (xi, yi) 。机器人无法走到障碍物上，它将会停留在障碍物的前一个网格方块上，但仍然可以继续尝试进行该路线的其余部分。返回从原点到机器人所有经过的路径点（坐标为整数）的最大欧式距离的平方。

**解题思路**:

1. 依照题意进行处理
   - 建立方向数组，方向数组的顺序应该是上右下左。
   - HashSet 将所有的障碍物位置存进去，可以将横纵坐标都转为字符串，然后在中间加个短横杆隔开
   - 行走过程中查看有没有障碍物，到 HashSet 中去查找一下，若没有障碍物，则可以到达，更新 x 和 y 为新的位置

**关联专题**: undefined

## Code

```cpp
// 2023-02-18 submission
// 48/48 cases passed
// Runtime: 203 ms, faster than 33.34% of C++ online submissions.
// Memory Usage: 36.9 MB, less than 52% of C++ online submissions.
class Solution {
public:
    int robotSim(vector<int>& commands, vector<vector<int>>& obstacles) {
        unordered_set<string> m_obs;
        for (vector<int> point : obstacles) {
            string pattern = to_string(point[0]) + "_" + to_string(point[1]);
            m_obs.insert(pattern);
        }
        vector<vector<int> > dirs{{0, 1}, {1, 0}, {0, -1}, {-1, 0}};
        int idx = 0, curX = 0, curY = 0, res = 0;
        for (int command : commands) {
            if (command == -2) idx = (idx + 3) % 4; // 负数取模后为负数
            else if (command == -1) idx = (idx + 1) % 4;
            else {
                while (command-- > 0) {
                    string pattern = to_string(curX + dirs[idx][0]) + "_" + to_string(curY + dirs[idx][1]);
                    if (!m_obs.count(pattern)) {
                        curX += dirs[idx][0];
                        curY += dirs[idx][1];
                    }
                }
                res = max(res, curX * curX + curY * curY);
            }
        }
        return res;
    }
};
```
