# [924.Minimize Malware Spread](https://leetcode.com/problems/minimize-malware-spread/description/)

## Description

**Tags**: array

**Companies**: Unknown

|  Category  |  Difficulty   | Likes | Dislikes |
| :--------: | :-----------: | :---: | :------: |
| algorithms | Hard (41.96%) |  944  |   561    |

<p>You are given a network of <code>n</code> nodes represented as an <code>n x n</code> adjacency matrix <code>graph</code>, where the <code>i<sup>th</sup></code> node is directly connected to the <code>j<sup>th</sup></code> node if <code>graph[i][j] == 1</code>.</p>
<p>Some nodes <code>initial</code> are initially infected by malware. Whenever two nodes are directly connected, and at least one of those two nodes is infected by malware, both nodes will be infected by malware. This spread of malware will continue until no more nodes can be infected in this manner.</p>
<p>Suppose <code>M(initial)</code> is the final number of nodes infected with malware in the entire network after the spread of malware stops. We will remove <strong>exactly one node</strong> from <code>initial</code>.</p>
<p>Return the node that, if removed, would minimize <code>M(initial)</code>. If multiple nodes could be removed to minimize <code>M(initial)</code>, return such a node with <strong>the smallest index</strong>.</p>
<p>Note that if a node was removed from the <code>initial</code> list of infected nodes, it might still be infected later due to the malware spread.</p>
<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<pre><code><strong>Input:</strong> graph = [[1,1,0],[1,1,0],[0,0,1]], initial = [0,1]
<strong>Output:</strong> 0</code></pre><p><strong class="example">Example 2:</strong></p>
<pre><code><strong>Input:</strong> graph = [[1,0,0],[0,1,0],[0,0,1]], initial = [0,2]
<strong>Output:</strong> 0</code></pre><p><strong class="example">Example 3:</strong></p>
<pre><code><strong>Input:</strong> graph = [[1,1,1],[1,1,1],[1,1,1]], initial = [1,2]
<strong>Output:</strong> 1</code></pre>
<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>
<ul>
  <li><code>n == graph.length</code></li>
  <li><code>n == graph[i].length</code></li>
  <li><code>2 &lt;= n &lt;= 300</code></li>
  <li><code>graph[i][j]</code> is <code>0</code> or <code>1</code>.</li>
  <li><code>graph[i][j] == graph[j][i]</code></li>
  <li><code>graph[i][i] == 1</code></li>
  <li><code>1 &lt;= initial.length &lt;= n</code></li>
  <li><code>0 &lt;= initial[i] &lt;= n - 1</code></li>
  <li>All the integers in <code>initial</code> are <strong>unique</strong>.</li>
</ul>

## Solution

**题目描述**

给定一个用邻接矩阵表示的图，其中一些节点 `initial` 最初被感染了病毒。只要两个节点直接连接，且其中至少一个节点受到病毒影响，那么两个节点都将被感染。这种病毒的传播会持续进行，直到没有更多的节点可以被这种方式感染。

假设 `M(initial)` 表示在病毒停止传播之后，整个图区域中感染病毒的节点数。如果从初始点列表 `initial` 中净化一个节点，使其不再被感染，如果这种情况下最终得到的 `M(initial)` 最小，返回该节点。如果有多个节点满足条件，返回索引最小的节点。

**解题思路**

1. BFS
   - 遍历 `initial` 中的每个节点，假设去掉该节点后，使用 BFS 模拟病毒传播，得到最终感染的节点数 `M(initial)`，记录下来。
   - BFS 过程中，初始时将所有感染的节点入队，然后依次出队，将与出队节点相连的未感染节点入队，直到队列为空，最后返回感染的节点数。
   - 为了加速查找邻接节点的过程，可以将邻接矩阵转换为邻接表。
   - 时间复杂度：$O(n^2)$ ，空间复杂度：$O(n)$ 。
2. 并查集
   - 首先使用并查集将图中的节点进行合并，得到连通分量。
   - 合并过程中需要记录每个连通分量的节点数。
   - 然后再统计每个连通分量中初始感染的节点数。
   - 检查所有的初始化感染节点，如果该节点所在的连通分量中只有一个初始感染节点，且该连通分量中的节点数最多，那么就选择该节点。
   - 如果没有初始感染节点数为 1 的连通分量，那么就返回 `initial` 中最小的节点
   - 时间复杂度：$O(n^2)$ ，空间复杂度：$O(n)$ 。

**测试用例**

- `initial` 不一定是有序的

**标签**

- breadth-first-search
- union-find
- graph

<!-- code start -->
## Code

### C++

```cpp
// 1. BFS
// 2024-01-15 submission
// 68/68 cases passed
// Runtime: 180 ms, faster than 29.14% of cpp online submissions.
// Memory Usage: 75.1 MB, less than 6.67% of cpp online submissions.
class Solution {
public:
    int minMalwareSpread(vector<vector<int>>& graph, vector<int>& initial) {
        int n = graph.size();
        vector<vector<int>> adj(n);
        for (int i = 0; i < n; ++i) {
            for (int j = i + 1; j < n; ++j) {
                if (graph[i][j] == 1) {
                    adj[i].push_back(j);
                    adj[j].push_back(i);
                }
            }
        }
        int min_m = n + 1, res = n + 1;
        for (int i = 0; i < initial.size(); ++i) {
            int m = bfs(adj, initial, i);
            if (m < min_m) {
                min_m = m;
                res = initial[i];
            }
            else if (m == min_m) {
                res = min(res, initial[i]);
            }
        }
        return res;
    }

    int bfs(vector<vector<int>>& adj, vector<int>& initial, int idx) {
        int n = adj.size();
        unordered_set<int> infected;
        queue<int> q;
        for (int i = 0; i < initial.size(); ++i) {
            if (i != idx) {
                q.push(initial[i]);
                infected.insert(initial[i]);
            }
        }
        while (!q.empty()) {
            int cur = q.front();
            q.pop();
            for (int next : adj[cur]) {
                if (!infected.count(next)) {
                    q.push(next);
                    infected.insert(next);
                }
            }
        }
        return infected.size();
    }
};
```

```cpp
// 2. 并查集
// 2024-01-15 submission
// 68/68 cases passed
// Runtime: 121 ms, faster than 99.26% of cpp online submissions.
// Memory Usage: 65.4 MB, less than 67.41% of cpp online submissions.
class Solution {
public:
    int find(vector<int>& parent, int x) {
        if (parent[x] == x) {
            return x;
        }
        return parent[x] = find(parent, parent[x]);
    }

    void _union(vector<int>& parent, vector<int>& size, int x, int y) {
        int rootX = find(parent, x);
        int rootY = find(parent, y);
        if (rootX == rootY) {
            return;
        }
        parent[rootY] = rootX;
        size[rootX] += size[rootY];
        size[rootY] = 0;
    }

    int minMalwareSpread(vector<vector<int>>& graph, vector<int>& initial) {
        int n = graph.size();
        vector<int> parent(n);
        vector<int> size(n);
        for (int i = 0; i < n; ++i) {
            parent[i] = i;
            size[i] = 1;
        }
        for (int i = 0; i < n; ++i) {
            for (int j = i + 1; j < n; ++j) {
                if (graph[i][j] == 1) {
                    _union(parent, size, i, j);
                }
            }
        }
        vector<int> initialCount(n);
        for (int i = 0; i < initial.size(); ++i) {
            initialCount[find(parent, initial[i])]++;
        }
        int ans = initial[0];
        int maxCount = 0;
        for (int i = 0; i < initial.size(); ++i) {
            int root = find(parent, initial[i]);
            if (initialCount[root] == 1) {
                if (size[root] > maxCount) {
                    maxCount = size[root];
                    ans = initial[i];
                }
                else if (size[root] == maxCount) {
                    ans = min(ans, initial[i]);
                }
            }
            else {
                if (initial[i] < ans) {
                    ans = initial[i];
                }
            }
        }
        return ans;
    }
};
```

<!-- code end -->
