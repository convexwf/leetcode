# [Generate Parentheses](https://leetcode.com/problems/generate-parentheses/description/)

## Description

**tags**: string,backtracking
**companies**: google,uber,zenefits

| Category | Difficulty | Likes | Dislikes |
| :------: | :--------: | :---: | :------: |
| algorithms | Medium (71.00%) | 14185 | 532 |

<p>Given <code>n</code> pairs of parentheses, write a function to <em>generate all combinations of well-formed parentheses</em>.</p>

<p>&nbsp;</p>
<p><strong>Example 1:</strong></p>
<pre><code><strong>Input:</strong> n = 3
<strong>Output:</strong> ["((()))","(()())","(())()","()(())","()()()"]</code></pre><p><strong>Example 2:</strong></p>
<pre><code><strong>Input:</strong> n = 1
<strong>Output:</strong> ["()"]</code></pre>
<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= n &lt;= 8</code></li>
</ul>

## Solution

**题目描述**: 给定一个数字 n，让生成共有 n 个括号的所有正确的形式。

**解题思路**

1. 递归
   - 定义两个变量 left 和 right 分别表示剩余左右括号的个数
   - 左括号为 0 时，将剩余右括号全部填入返回结果。
   - 左括号不为 0 时，添加左括号进入递归
   - 左括号个数少于右括号时，添加右括号进入递归。
2. 每找到一个左括号，就在其后面加一个完整的括号，最后再在开头加一个 ()，就形成了所有的情况，需要注意的是，有时候会出现重复的情况，所以用 set 数据结构进行存储。

**关联专题**: undefined

## Code

```cpp
// 2023-01-30 submission
// 8/8 cases passed
// Runtime: 0 ms, faster than 100% of C++ online submissions.
// Memory Usage: 7.3 MB, less than 96.84% of C++ online submissions.
class Solution {
public:
    vector<string> generateParenthesis(int n) {
        vector<string> res;
        string cur = "";
        int lp = n, rp = n;
        helper(res, cur, lp, rp);
        return res;
    }

    void helper(vector<string>& res, string cur, int lp, int rp) {
        if (lp == 0) {
            res.push_back(cur + string(rp - lp, ')'));
            return;
        }
        helper(res, cur + "(", lp - 1, rp);
        if (lp < rp) helper(res, cur + ")", lp, rp - 1);
    }
};
```

```cpp
// 2023-01-30 submission
// 8/8 cases passed
// Runtime: 3 ms, faster than 83.32% of C++ online submissions.
// Memory Usage: 7.6 MB, less than 95.62% of C++ online submissions.
class Solution {
public:
    vector<string> generateParenthesis(int n) {
        unordered_set<string> st;
        if (n == 0) st.insert("");
        else {
            vector<string> pre = generateParenthesis(n - 1);
            for (string a : pre) {
                for (int i = 0; i < a.size(); ++i) {
                    if (a[i] == '(') {
                        string tmp = a.substr(0, i + 1) + "()" + a.substr(i + 1);
                        st.insert(tmp);
                    }
                }
                st.insert("()" + a);
            }
        }
        return vector<string>(st.begin(), st.end());
    }
};
```
