# [3Sum Closest](https://leetcode.com/problems/3sum-closest/description/)

## Description

**tags**: array,two-pointers
**companies**: bloomberg

|  Category  |   Difficulty    | Likes | Dislikes |
| :--------: | :-------------: | :---: | :------: |
| algorithms | Medium (46.64%) | 6313  |   310    |

<p>Given an integer array <code>nums</code> of length <code>n</code> and an integer <code>target</code>, find three integers in <code>nums</code> such that the sum is closest to <code>target</code>.</p>

<p>Return <em>the sum of the three integers</em>.</p>

<p>You may assume that each input would have exactly one solution.</p>

<p>&nbsp;</p>
<p><strong>Example 1:</strong></p>

<pre><code><strong>Input:</strong> nums = [-1,2,1,-4], target = 1
<strong>Output:</strong> 2
<strong>Explanation:</strong> The sum that is closest to the target is 2. (-1 + 2 + 1 = 2).</code></pre>

<p><strong>Example 2:</strong></p>

<pre><code><strong>Input:</strong> nums = [0,0,0], target = 1
<strong>Output:</strong> 0</code></pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
  <li><code>3 &lt;= nums.length &lt;= 1000</code></li>
  <li><code>-1000 &lt;= nums[i] &lt;= 1000</code></li>
  <li><code>-10<sup>4</sup> &lt;= target &lt;= 10<sup>4</sup></code></li>
</ul>

## Solution

**题目描述**: 一个长度为 n 的整数数组 nums 和 一个目标值 target，从 nums 中选出三个整数，使它们的和与 target 最接近。返回这三个数的和。

**解题思路**:

1. 排序+双指针

**关联专题**: undefined

## Code

```cpp
// 2023-02-28 submission
// 98/98 cases passed
// Runtime: 41 ms, faster than 93.95% of C++ online submissions.
// Memory Usage: 10.2 MB, less than 85% of C++ online submissions.
class Solution {
public:
    int threeSumClosest(vector<int>& nums, int target) {
        int closestVal = nums[0] + nums[1] + nums[2];
        sort(nums.begin(), nums.end());
        int lval = 0, rval = 0, pivot = 0, cur_sum = 0;
        for (int i = 0; i < (int)nums.size() - 2; i++) {
            pivot = nums[i];
            if (i > 0 && nums[i] == nums[i - 1]) continue;
            for (int left = i + 1, right = (int)nums.size() - 1; left < right;) {
                cur_sum = nums[left] + nums[right] + pivot;
                if (cur_sum == target) return target;
                if (cur_sum > target) right--;
                if (cur_sum < target) left++;
                if (abs(target - cur_sum) < abs(target - closestVal)) closestVal = cur_sum;
            }
        }
        return closestVal;
    }
};
```
