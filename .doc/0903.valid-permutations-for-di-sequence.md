# [903.Valid Permutations for DI Sequence](https://leetcode.com/problems/valid-permutations-for-di-sequence/description/)

## Description

**Tags**: random,rejection-sampling

**Companies**: Unknown

|  Category  |  Difficulty   | Likes | Dislikes |
| :--------: | :-----------: | :---: | :------: |
| algorithms | Hard (57.36%) |  723  |    43    |

<p>You are given a string <code>s</code> of length <code>n</code> where <code>s[i]</code> is either:</p>
<ul>
  <li><code>&#39;D&#39;</code> means decreasing, or</li>
  <li><code>&#39;I&#39;</code> means increasing.</li>
</ul>
<p>A permutation <code>perm</code> of <code>n + 1</code> integers of all the integers in the range <code>[0, n]</code> is called a <strong>valid permutation</strong> if for all valid <code>i</code>:</p>
<ul>
  <li>If <code>s[i] == &#39;D&#39;</code>, then <code>perm[i] &gt; perm[i + 1]</code>, and</li>
  <li>If <code>s[i] == &#39;I&#39;</code>, then <code>perm[i] &lt; perm[i + 1]</code>.</li>
</ul>
<p>Return <em>the number of <strong>valid permutations</strong> </em><code>perm</code>. Since the answer may be large, return it <strong>modulo</strong> <code>10<sup>9</sup> + 7</code>.</p>
<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<pre><code><strong>Input:</strong> s = &quot;DID&quot;
<strong>Output:</strong> 5
<strong>Explanation:</strong> The 5 valid permutations of (0, 1, 2, 3) are:
(1, 0, 3, 2)
(2, 0, 3, 1)
(2, 1, 3, 0)
(3, 0, 2, 1)
(3, 1, 2, 0)</code></pre>
<p><strong class="example">Example 2:</strong></p>
<pre><code><strong>Input:</strong> s = &quot;D&quot;
<strong>Output:</strong> 1</code></pre>
<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>
<ul>
  <li><code>n == s.length</code></li>
  <li><code>1 &lt;= n &lt;= 200</code></li>
  <li><code>s[i]</code> is either <code>&#39;I&#39;</code> or <code>&#39;D&#39;</code>.</li>
</ul>

## Solution

**题目描述**

给定一个长度为 `n` 的字符串 `s`，其中 `s[i]` 是：

- `D` 表示递减
- `I` 表示递增

一个长度为 `n+1` 的排列 `perm` 是一个有效排列，如果对于所有有效的 `i`：

- 如果 `s[i] == 'D'`，那么 `perm[i] > perm[i+1]`
- 如果 `s[i] == 'I'`，那么 `perm[i] < perm[i+1]`
- `s[i]` 在 `[0, n]` 范围内

返回有效排列的个数，由于答案可能很大，返回对 `10^9 + 7` 取模的结果。

**解题思路**

1. 动态规划
   - 状态定义：`dp[i][j]` 表示有 `i + 1` 个数组成，且第 `i + 1` 个数（即最后一个数）是剩余数字中（包括当前数组）中第 `j + 1` 小的数的排列方案数。
     - 比如 `dp[0][0]` 表示序列只有 1 个数，且这个数是剩余数字中最小的数（即 0），只有一种排列方式。
     - 比如 `dp[1][2]` 表示序列有 2 个数，且最后一个数是剩余数字中第 3 小的数，

1. 动态规划
   - 状态定义：`dp[i][j]` 表示处理前 `i` 个字符（即 `s[0:i-1]`）时，且以第 `j` 个数结尾的满足条件的方案数。
   - 状态初始化：`dp[0][j] = 1`，其中 `j` 从 `0` 到 `n`，所有可能的数字都可以作为尾部，所以初始时都只有一种排列方式。
   - 状态转移：
     - 如果 `s[i] == 'I'`，意味着第 `i+1` 个数字需要大于第 `i` 个数字，

```cpp
class Solution {
public:
    int numPermsDISequence(string S) {
        int n = S.size(), M = 1e9 + 7;
        vector<vector<int>> dp(n + 1, vector<int>(n + 1));
        for (int j = 0; j <= n; ++j) {
            dp[0][j] = 1;
        }
        for (int i = 0; i < n; ++i) {
            if (S[i] == 'I') {
                int cur = 0;
                for (int j = 0; j < n - i; ++j) {
                    cur = (cur + dp[i][j]) % M;
                    dp[i + 1][j] = cur;
                }
            }
            else {
                int cur = 0;
                for (int j = n - 1 - i; j >= 0; --j) {
                    cur = (cur + dp[i][j + 1]) % M;
                    dp[i + 1][j] = cur;
                }
            }
        }
        return dp[n][0];
    }
};
```
