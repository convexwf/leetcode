# LeetCode

## 3

**题目描述**

求最长无重复子串

**解题思路**

1. 滑动窗口：建立字符到其出现次数或者最后出现位置的映射，并且定义一个变量标记当前滑动窗口的左边界。对于 char 数据类型的hashmap，可以用 `vector<int> m(256, 0)` 代替。

## 5

**题目描述**

最长回文子串。

**解题思路**

1. 动态规划
   - `dp[i][j]` 表示 s.substr(i, j - i + 1) 是否为回文子串
   - 初始状态：`dp[i][i] = true`
   - 状态转移方程：`dp[i][j] = dp[i+1][j-1] if s[i] = s[j]`，其他情况下 `dp[i][j] = false`
   - 遍历顺序：从小区间遍历到大区间
2. 马拉车算法：TODO

## 6

**题目描述**

给定字符串和行数，将其进行 “之” 形变换后，输出逐行读取的结果。

```txt
当 n = 2 时：

0 2 4 6 8 A C E
1 3 5 7 9 B D F

result: 0 2 4 6 8 A C E 1 3 5 7 9 B D F

当 n = 3 时：

0   4   8   C
1 3 5 7 9 B D F
2   6   A   E

当 n = 4 时：

0     6     C
1   5 7   B D
2 4   8 A   E
3     9     F
```

**解题思路**

1. 找规律
   - 第一行和最后一行没有中间形成之字型的数字中，相邻两个元素的 index 之差为 2*nRows - 2。
   - 除了第一行和最后一行，中间数字每两个非紧靠的数字的 index 之差为 2 x numRows-2 - 2 x i，i 为当前行数。

## 7

**题目描述**

数字翻转，注意溢出问题。

**解题思路**

1. 从最后一位数字开始算，每次需要判断是否大于 INT_MAX / 10，否则返回 0.

**Follow Up**

1. 为什么不需要判断等于 INT_MAX / 10

## 8

**题目描述**

字符串转为整数

**解题思路**

1. 若字符串开头是空格，则跳过所有空格，到第一个非空格字符，如果没有，则返回0.
2. 若第一个非空格字符是符号 +/-，则标记 sign 的真假，这道题还有个局限性，那就是在 c++ 里面，+-1 和-+1 都是认可的，都是 -1，而在此题里，则会返回0.
3. 若下一个字符不是数字，则返回0，完全不考虑小数点和自然数的情况。
4. 如果下一个字符是数字，则转为整型存下来，若接下来再有非数字出现，则返回目前的结果。
5. 还需要考虑边界问题，如果超过了整型数的范围，则用边界值替代当前值。

## 9

**题目描述**

判断一个整数是否是回文数

**解题思路**

1. 分别取最左和最右的数字，然后向中间靠拢。
2. 将数字从中间一分为二。
   - 整数的最高位不能是 0，所以回文数的最低位也不能为0，数字 0 除外
   - 回文数不可能是负数
   - 把后半段翻转，看是否和前半段相等
   - 每次通过对 10 取余，取出最低位的数字，然后加到取出数的末尾
   - 当 revertNum 大于等于x的时候循环停止。由于回文数的位数可奇可偶，如果是偶数，revertNum 应该和x相等；如果是奇数，最中间的数字就在 revertNum 的最低位，除以 10 以后应该和x是相等的
3. 回文数反转后仍是原数字，所以不可能溢出。只要溢出就说明不是回文数。

## 10

**题目描述**

正则匹配：`.` 匹配任意单个字符，`*` 匹配 0 个或多个前置字符。

**解题思路**

1. 正则匹配
   - sp 和 pp 都到了末尾，表示匹配结束
   - 如果 p 的后置字符为 *，(1) p 的当前字符为 . (2) p 的当前字符匹配 s 的当前字符，如果满足上述两种情况之一，s 后移一位，继续递归。
   - 如果上述情况返回错误，说明 * 匹配失效，p 后移两位，继续递归。
   - 最后进行普通匹配，(1) p 的当前字符为 . (2) p 的当前字符匹配 s 的当前字符，如果满足上述两种情况之一，s 和 p 均后移一位，继续递归。
2. 动态规划
   - `dp[i][j]` 表示 s[0,i) 和 p[0,j) 是否 match
   - `dp[i][j] = dp[i - 1][j - 1]`, if `p[j - 1] != '*' && (s[i - 1] == p[j - 1] || p[j - 1] == '.')`;
   - `dp[i][j] = dp[i][j - 2]`, if `p[j - 1] == '*'` and the pattern repeats for 0 times;
   - `dp[i][j] = dp[i - 1][j] && (s[i - 1] == p[j - 2] || p[j - 2] == '.')`, if `p[j - 1] == '*'` and the pattern repeats for at least 1 times.

TODO 贪婪匹配 VS 非贪婪匹配

## 11

**题目描述**

给定 n 个非负整数 a1，a2，…，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0) 。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。

**解题思路**

1. 双指针
   - 两个指针分别指向数组的左右两端，然后两个指针向中间搜索，每移动一次算一个值和结果比较取较大值
   - 优化处理：对于相同的高度们直接移动指针即可，不再进行计算容量

## 12

**题目描述**

整数转化成罗马数字

**解题思路**

```txt
I - 1
V - 5
X - 10
L - 50
C - 100
D - 500
M - 1000
```

1. 贪婪算法
   - 建立一个数表，每次通过查表找出当前最大的数，减去再继续查表

## 13

**题目描述**

罗马数转化成数字。

```txt
I - 1
V - 5
X - 10
L - 50
C - 100
D - 500
M - 1000
```

基本规则：

1、相同的数字连写，所表示的数等于这些数字相加得到的数，如：`III` = 3；
2、小的数字在大的数字的右边，所表示的数等于这些数字相加得到的数， 如：`VIII` = 8；`XII` = 12；
3、小的数字，（限于 `Ⅰ`、`X` 和 `C`）在大的数字的左边，所表示的数等于大数减小数得到的数，如：`IV`= 4；`IX`= 9；
4、正常使用时，连写的数字重复不得超过三次。（表盘上的四点钟 `IIII` 例外）
5、在一个数的上面画一条横线，表示这个数扩大 1000 倍。
6、基本数字 `Ⅰ`、`X`、`C` 中的任何一个，自身连用构成数目，或者放在大数的右边连用构成数目，都不能超过三个；放在大数的左边只能用一个。
7、不能把基本数字 `V`、`L`、`D` 中的任何一个作为小数放在大数的左边采用相减的方法构成数目；放在大数的右边采用相加的方式构成数目，只能使用一个。
8、`V` 和 `X` 左边的小数字只能用 `Ⅰ`。
9、`L` 和 `C` 左边的小数字只能用 `X`。
10、`D` 和 `M` 左边的小数字只能用 `C`。

**解题思路**

1. HashMap：将罗马数字的字母转化为对应的整数值，因为输入的一定是罗马数字，那么只要考虑两种情况即可：
   - 如果当前数字是最后一个数字，或者之后的数字比它小的话，则加上当前数字。
   - 其他情况则减去这个数字。
2. 每次跟前面的数字比较，如果小于等于前面的数字，先加上当前的数字，如果大于前面的数字，加上当前的数字减去二倍前面的数字。

## 14

**题目描述**

最长公共前缀

**解题思路**

1. 排序
    - 给输入字符串数组排序，有共同字母多的两个字符串会被排到一起，所以只需要找首尾字母串的共同前缀即可。
    - 为了防止溢出错误，只遍历而这种较短的那个的长度，找出共同前缀返回即可。

## 15

**题目描述**

三数之和。

**解题思路**

1. 排序 + 双指针
    - (1) 对原数组进行排序，然后开始遍历排序后的数组，遍历到倒数第三个即可。即 fix 一个数，然后去找另外两个数，只要找到两个数且和为第一个 fix 数的相反数就行。
    - (2) 剪枝优化: 遍历到正数的时候跳出循环。
    - (3) 重复数处理: fix 的数字和双指针都需要处理。

## 16

**题目描述**

一个长度为 n 的整数数组 nums 和 一个目标值 target，从 nums 中选出三个整数，使它们的和与 target 最接近。返回这三个数的和。

**解题思路**

1. 排序+双指针

## 17

**题目描述**

给定数字串，求电话号码的字母组合

**解题思路**

1. BFS: 遍历 digits 中所有的数字时，先建立一个临时的字符串数组 t，通过数字到 dict 中取出字符串 str，然后遍历取出字符串中的所有字符，再遍历当前结果 res 中的每一个字符串，将字符加到后面，并加入到临时字符串数组 t 中。取出的字符串 str 遍历完成后，将临时字符串数组赋值给结果 res。
2. DFS
    - 需要一个变量 level，记录当前生成的字符串的字符个数(递归层数)。
    - 在递归函数中首先判断 level，如果跟 digits 中数字的个数相等了，将当前的组合加入结果 res 中，然后返回。
    - 将每个字符都加到当前的组合后面，并调用递归函数即可

## 18

**题目描述**

四数之和，给定一个包含 n 个整数的数组 nums 和一个目标值 target，判断 nums 中是否存在四个元素 a，b，c 和 d ，使得 a + b + c + d 的值与 target 相等？找出所有满足条件且不重复的四元组。

**解题思路**

1. 排序+双指针：两层循环后进行双指针查找，注意去重处理，O(n^3) 时间复杂度。

TODO

1. 时间复杂度更低的做法，比如建立和到两个数的映射

## 19

**题目描述**

移除链表倒数第 N 个节点，限定 N 一定是有效的。

**解题思路**

1. 递归: 增加一个标记变量，每递归一次函数就将变量-1，当标记为 0 时当前遍历节点为需要删除的节点，此时返回其指向的下一个节点，其他情况下返回自身。
2. 迭代+双指针
    - 首先快指针先向前走 n 步，如果走不到 n 步说明链表数量小于 n，不需要做任何处理，返回 head 指针。
    - 如果走了 n 步快指针指向空，说明链表数量正好等于 n，返回 head 指向的下一个节点。
    - 如果不是以上情况，慢指针和快指针同时出发，当快指针到末尾时，慢指针指向的就是需要移除的节点。

## 20

**题目描述**

验证输入的字符串是否为有效的括号字符串，包括大括号，中括号和小括号。

**解题思路**

1. 栈
    - 开始遍历输入字符串，如果当前字符为左半边括号时，则将其压入栈中，
    - 如果遇到右半边括号时，若此时栈为空，则直接返回 false，如不为空，则取出栈顶元素，若为对应的左半边括号，则继续循环，反之返回 false

## 21

**题目描述**

混合两个有序链表

**解题思路**

1. 迭代
   - 比较两个链表中的元素值，把较小的那个链到新链表中
   - 由于两个输入链表的长度可能不同，所以最终会有一个链表先完成插入所有元素，则直接另一个未完成的链表直接链入新链表的末尾。
2. 递归
   - 某个链表为空了，就返回另一个
   - 如果 l1 的值较小，那么对于 l1 的下一个节点和 l2 调用递归函数，将返回值赋值给 l1.next，然后返回 l1；
   - 否则就对于 l2 的下一个节点和 l1 调用递归函数，将返回值赋值给 l2.next，然后返回 l2

## 22

**题目描述**

给定一个数字 n，让生成共有 n 个括号的所有正确的形式。

**解题思路**

1. 递归
   - 定义两个变量 left 和 right 分别表示剩余左右括号的个数
   - 左括号为 0 时，将剩余右括号全部填入返回结果。
   - 左括号不为 0 时，添加左括号进入递归
   - 左括号个数少于右括号时，添加右括号进入递归。
2. 每找到一个左括号，就在其后面加一个完整的括号，最后再在开头加一个 ()，就形成了所有的情况，需要注意的是，有时候会出现重复的情况，所以用 set 数据结构进行存储。

## 23

**题目描述**

合并 k 个有序链表

**解题思路**

1. 迭代+最小堆
   - 把k个链表的首元素都加入最小堆中，它们会自动排好序。
   - 每次取出最小的那个元素加入最终结果的链表中，然后把取出元素的下一个元素再加入堆中，下次仍从堆中取出最小的元素做相同的操作
   - 以此类推，直到堆中没有元素了，此时k个链表也合并为了一个链表，返回首节点即可

## 24

**题目描述**

交换链表的相邻节点。

**解题思路**

1. 递归：递归遍历到链表末尾，然后先交换末尾两个，然后依次往前交换
2. 迭代：建立 dummy 节点

## 25

**题目描述**

k 个为一组来翻转链表

**解题思路**

1. 迭代：首先遍历整个链表，统计出链表的长度，然后如果长度大于等于k，交换节点，当 k=2 时，每段只需要交换一次，当 k=3 时，每段需要交换2此，所以 i 从 1 开始循环，注意交换一段后更新 pre 指针，然后 num 自减 k，直到 $num < k$ 时循环结束。
2. 递归：用 head 记录每段的开始位置，cur 记录结束位置的下一个节点，然后调用 reverse 函数来将这段翻转，然后得到一个 new_head，原来的 head 就变成了末尾，这时候后面接上递归调用下一段得到的新节点，返回 new_head 即可。

## 26

**题目描述**

给定一个排序数组，就地删除重复项，以便每个元素只出现一次，并返回新长度

**解题思路**

undefined

## 27

**题目描述**

删除 array 中的给定值

**解题思路**

undefined

## 28

**题目描述**

实现 `strStr()` 函数，返回字符串 needle 在字符串 haystack 中的第一次出现位置。

**解题思路**

1. 遍历母字符串，这里并不需要遍历整个母字符串，而是遍历到剩下的长度和子字符串相等的位置即可，这样可以提高运算效率。然后对于每一个字符，都遍历一遍子字符串，一个一个字符的对应比较，如果对应位置有不等的，则跳出循环，如果一直都没有跳出循环，则说明子字符串出现了，则返回起始位置即可

**边界条件**

1. 注意 haystack 或者 needle 长度为 0 的情况
2. 注意 haystack 长度比 needle 小的情况

TODO

1. KMP

## 29

**题目描述**

求两数相除，规定不能用乘法，除法和取余操作。

**解题思路**

1. 位操作
   - 不准使用乘除幂运算的情况下，都要使用位操作。
   - 如果被除数大于或等于除数，则进行如下循环，定义变量 t 等于除数，定义计数 p，当 t 的两倍小于等于被除数时，进行如下循环， t 扩大一倍，p 扩大一倍，然后更新 res 和 m。
   - 去除符号后再做运算，结果再加上符号
   - 运算过程中可能会发生溢出，要用 long 表示
2. 上述方法的递归形式

**边界条件**

1. 被除数是 INT_MAX，除数是 INT_MIN
2. 被除数是 INT_MIN，除数是 -1
3. 被除数是 0

## 30

**题目描述**

给定一个长字符串，再给定几个长度相同的单词，让找出串联给定所有单词的子串的起始位置。

**解题思路**

1. HashMap
   - 先用 check_freq 存储单词表的频率，然后词遍历字符串。
   - 词遍历是先遍历0,4,8,12,...，再遍历1,5,9,13,...，再遍历2,6,10,14...。词遍历过程中要维护一个哈希表 word_freq 表示当前匹配的单词数量，还有维护一个左边界表示当前匹配的最左位置。
   - 当当前位置减去左边界等于总长度而且维护的哈希表满足时，说明左边界为所需要的结果之一。
   - 当前位置不匹配时，需要将左边界前移并且清空匹配 map。
   - s.substr(pos,n)：若pos的值超过了string的大小，则substr函数会抛出一个out_of_range异常；若pos+n的值超过了string的大小，则substr会调整n的值。
   - O(n) 时间复杂度。
2. 遍历 s 中所有长度为 n\*len 的子串，当剩余子串的长度小于 n\*len 时，就不用再判断了。对于每个遍历到的长度为 n\*len 的子串，需要验证其是否刚好由 words 中所有的单词构成，检查方法就是每次取长度为 len 的子串，看其是否是 words 中的单词。为了方便比较，建立另一个 HashMap，当取出的单词不在 words 中，直接 break 掉，否则就将其在新的 HashMap 中的映射值加 1，还要检测若其映射值超过原 HashMap 中的映射值，也 break 掉，因为就算当前单词在 words 中，但若其出现的次数超过 words 中的次数，还是不合题意的。在 for 循环外面，若 j 正好等于n ，说明检测的 n 个长度为 len 的子串都是 words 中的单词，并且刚好构成了 words，则将当前位置 i 加入结果 res 即可。

**边界条件**

1. 待选单词可能会重复（两个以上同样的词），建议先用一个hashmap存储单词表的频率
2. 单词表为空
3. 待选单词长度为 0
4. 查找字符串长度为 0

## 31

**题目描述**

全排列的下一个

**解题思路**

1. 从后往前找到第一个递减的数字 i，然后从后往前找到第一个比 i 大的数字 j，交换 i 和 j，再将 j 后面的所有数字反转即可。

**边界条件**

1. 已经是最大的排列，比如说 “54321”

## 32

**题目描述**

求最长有效括号的长度

**解题思路**

1. 动态规划: 每个位置存 包括当前位置的有效最长长度。
   - 如果当前位置是 ')'，检查前一位的最长长度 k，检查当前位置减去 k+1 的位置是否为 '('，当前位置为 k+2
   - 并且还要加上减去 k+2 的位置的最长长度
   - 当前位置减去 k+1 的位置下标有可能小于 0，所以可以在字符串最开始加个占位符
2. 对左括号和右括号进行计数
   - 从左到右遍历，当遇到左括号时，left 自增1，右括号时 right 自增1。
   - 对于最长有效的括号的子串，一定是左括号等于右括号的情况
   - 右括号数量超过左括号数量，说明当前位置不能组成合法括号子串
   - 对于 "(()" 时，在遍历结束时左右子括号数都不相等，此时没法更新结果 res，所以还需要从右至左进行遍历
3. 栈
   - 定义个 start 变量来记录合法括号串的起始位置
   - 遍历字符串，如果遇到左括号，则将当前下标压入栈，如果遇到右括号，如果当前栈为空，则将下一个坐标位置记录到 start
   - 如果栈不为空，则将栈顶元素取出，此时若栈为空，则更新结果和 i - start + 1 中的较大值，否则更新结果和 i - st.top() 中的较大值

## 33

**题目描述**

在旋转数组中搜索一个给定值，返回坐标，若不存在返回 -1，数组中*无*重复值。

**解题思路**

1. 二分搜索
   - 如果中间的数小于最右边的数，则右半段是有序的，若中间数大于最右边数，则左半段是有序的，
   - 在有序的半段里用首尾两个数来判断目标值是否在这一区域内，这样就可以确定保留哪半边。
   - 为什么一定要用中间的数字跟最右边的比较？能不能和最左边进行比较？
    二分搜索中，nums[mid] 和 nums[left] 有可能相等，比如数组中只有两个元素。由于只有两个数字且 nums[mid] 不等于 target，target 只有可能在右半边出现，最好的方法就是让其无法进入左半段，就需要左半段是有序的，而且由于一定无法同时满足 nums[left] <= target && nums[mid] > target，因为 nums[left] 和 nums[mid] 相等，同一个数不可能同时大于等于 target，又小于 target。由于这个条件不满足，则直接进入右半段继续搜索即可，所以等于的情况要加到 nums[mid] > nums[left] 的情况中，变成大于等于。

## 34

**题目描述**

找到排序数组中给定值第一次出现和最后一次出现的位置，要求 O(logn) 时间复杂度

**解题思路**

1. 二分搜索
   - 在数组中查找第一个大于等于 target 的位置
   - 当返回的位置越界，或者该位置上的值不等于 target 时，表示数组中没有 target，直接返回 {-1, -1} 即可
   - 若查找到了 target 值，则再查找第一个大于等于 target+1 的位置，然后把返回的位置减1，就是 target 的最后一个位置

**边界条件**:

1. 数组长度为 0
2. 待查找数字不在数组中

## 35

**题目描述**

搜索给定值在数组的插入位置。

**解题思路**

1. 二分搜索，查找不小于目标值的数。

## 36

**题目描述**

检查数独有效性(只限已填的数字)，数独有效不一定存在解

**解题思路**

1. 位操作:
   - 建立一个长度为 9 的数组 valid
   - valid[i] 是一个 32 位整型，前 9 位标记数字 i 是否在对应的行中; 9-18 位标记数字 i 是否在对应的列中; 19-27 位标记数字 i 是否在对应的九宫格中
   - 遍历数独二维数组，如果当前格子有数字，检查是否能够计入 valid
2. 哈希表
   - 建立一个哈希表，每个格子里的数字都会向哈希表填入三个字符串
   - 假设数独表 `board[x][y]=n`，三个字符串为 `x(n)` `(n)y` `x/3(n)y/3`，分别表示数字 n 在行、列、九宫格上的分布

## 37

**题目描述**

给出数独的解

**解题思路**

1. 位操作 + 回溯
   - 建立一个长度为 9 的数组 valid
   - valid[i] 是一个 32 位整型，前 9 位标记数字 i 是否在对应的行中; 9-18 位标记数字 i 是否在对应的列中; 19-27 位标记数字 i 是否在对应的九宫格中
   - 遍历数独二维数组，如果当前格子有数字，检查是否能够计入 valid
   - 剪枝操作: 题目只要求返回一个解，只要找到就可以返回 true

## 38

**题目描述**

对于前一个数，找出相同连续元素的个数

**解题思路**

undefined

## 39

**题目描述**

给定正整数候选数集合 candidates 和目标和 target，找出 candidates 中所有可以使数字和为 target 的组合，candidates 中的数字可以无限制重复被选取。候选数集合中不会出现重复数字。

**解题思路**

1. 递归：加入三个变量，start 记录当前的递归到的下标，out 为一个解，res 保存所有已经得到的解，每次调用新的递归函数时，此时的 target 要减去当前数组的的数。
2. 迭代：建立一个三维数组 dp，dp[i] 表示目标数为 i+1 的所有解法集合。

## 40

**题目描述**

给定一个正整数候选数集合 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。candidates 中的每个数字在每个组合中只能使用一次。候选数集合中不会出现重复数字。

**解题思路**

1. 递归

## 41

**题目描述**

找缺失的首个正数，限定 O(n) 时间复杂度和不使用额外空间。

**解题思路**

1. 把 1 放在数组第一个位置 nums[0]，2 放在第二个位置 nums[1]，即需要把 nums[i] 放在 nums[nums[i] - 1] 上。遍历整个数组，如果 nums[i] != i + 1, 而 nums[i] 为整数且不大于n，另外 nums[i] 不等于 nums[nums[i] - 1] 的话，将两者位置调换，如果不满足上述条件直接跳过，最后再遍历一遍数组，如果对应位置上的数不正确则返回正确的数。

## 42

**题目描述**

接雨水问题。

**解题思路**

1. 每个位置能接的雨水量是：当前位置左边最高的数与右边最高的数的最小值减去当前位置的数（注意不能为负数）。所以需要遍历两遍数组，第一遍在 dp[i] 中存入i位置左边的最大值，然后开始第二遍遍历数组，第二次遍历时找右边最大值，然后和左边最大值比较取其中的较小值。
2. 只遍历一次数组
   - left 和 right 两个指针分别指向数组的首尾位置，从两边向中间扫描
   - 在当前两指针确定的范围内，先比较两头找出较小值，如果较小值是 left 指向的值，则从左向右扫描，如果较小值是 right 指向的值，则从右向左扫描
   - 若遇到的值比当较小值小，则将差值存入结果，如遇到的值大，则重新确定新的窗口范围，以此类推直至 left 和 right 指针重合
3. 栈
   - 遍历高度，如果此时栈为空，或者当前高度小于等于栈顶高度，则把当前高度的坐标压入栈
   - 当遇到比栈顶高度大的时候，就说明有可能会有坑存在，可以装雨水。此时栈里至少有一个高度，如果只有一个的话，那么不能形成坑，直接跳过
   - 如果多于一个的话，那么此时把栈顶元素取出来当作坑，新的栈顶元素就是左边界，当前高度是右边界，只要取二者较小的，减去坑的高度，长度就是右边界坐标减去左边界坐标再减1，二者相乘就是盛水量

**边界条件**

1. 高度列表长度小于3

## 43

**题目描述**

大数相乘

**解题思路**

1. 两数相乘得到的乘积的长度其实其实不会超过两个数字的长度之和。num1 中位置为 i 的数字乘以 num2 中位置为 j 的数字，那么得到的两位数字的位置为 i+j 和 i+j+1。

**边界条件**:

1. 其中一个输入是 “0” 或者都是 “0”

## 44

**题目描述**

外卡匹配，`?` 匹配任意单个字符，`*` 匹配 0 个或多个字符

**解题思路**

1. 动态规划
   - dp[i][j] 表示 p 前 i 个字符 和 s 前 j 个字符是否匹配
   - if p[i-1] == s[j-1] or p[i-1] == '?', dp[i][j]=dp[i-1][j-1]
   - if p[i-1] == '*', dp[i][j]=dp[i-1][j] or dp[i][j-1]
2. 递归
   - 有三种不同的状态，返回0表示匹配到了s串的末尾，但是未匹配成功；返回1表示未匹配到s串的末尾就失败了；返回2表示成功匹配。那么只有返回值大于1，才表示成功匹配。
   - 在递归函数中，若s串和p串都匹配完成了，返回状态2。若s串匹配完成了，但p串但当前字符不是星号，返回状态0。若s串未匹配完，p串匹配完了，返回状态1。
   - 若s串和p串均为匹配完，且当前字符成功匹配的话，对下一个位置调用递归。否则若p串当前字符是星号，首先跳过连续的星号。然后分别让星号匹配空串，一个字符，两个字符，....，直到匹配完整个s串，对每种情况分别调用递归函数，接下来就是最大的亮点了，也是最有用的剪枝，当前返回值为状态0或者2的时候，返回，否则继续遍历。

**边界条件**:

1. p 和 s 长度均为 0 时，结果为true
2. s 长度为 0，p 为只由 * 组成的字符串，结果为 true

## 45

**题目描述**

给定一个非负整数数组 nums，最初位于数组的第一个位置，数组中的每个元素代表在该位置可以跳跃的最大长度，目标是使用最少的跳跃次数到达数组的最后一个位置。

**解题思路**

1. 贪心算法：cur 是当前能到达的最远位置，last 是上一步能到达的最远位置，遍历数组。判断如果当前位置超过 last，即上一步能到达的最远位置，说明需要再跳一次。判断如果 cur 到达末尾。注意至少要跳一次，所以初始化为 1。

**边界条件**:

1. 数组长度只有 1

## 46

**题目描述**

全排列，输入数组没有重复项

**解题思路**

1. DFS
    - 用一个 visited 数组来标记某个数字是否访问过
    - 用 level 标记当前的递归深度，深度等于输入数组长度表示当前结果合法，加入结果集中

## 47

**题目描述**

数组存在重复值，返回不重复全排列。

**解题思路**

1. Map+递归
   - 使用 map 而非 unordered_map 是为了使值有序
   - 防止重复的关键就是在每个填充位对于相同的数字只能够填一次

## 48

**题目描述**

二维矩阵顺时针 90 度旋转

**解题思路**

1. 顺时针的顺序去覆盖
    - 对于 n 是偶数的情况，只需要将四个对角的元素进行调换即可；
    - 如果 n 是奇数，这中间有个十字会重复移动，所以要单独处理。
2. 首先对原数组取其转置矩阵，然后把每行的数字翻转可得到结果

## 49

**题目描述**

归类给定字符串集中所有的错位词。错位词指的是两个字符串中字母出现的次数都一样，只是位置不同。

**解题思路**

1. 排序+hashmap
    - 错位词重新排序后都会得到相同的字符串
    - 排序后的字符串作为 key，res 对应集合的下标为 value
    - 当检测到当前的单词不在 HashMap 中，此时知道这个单词将属于一个新的错位词集合，所以将其映射为当前的错位词集合的个数，然后在 res 中新增一个空集合
2. hashmap，不排序
    - 用一个大小为 26 的 int 数组来统计每个单词中字符出现的次数，然后将 int 数组转为一个唯一的字符串，跟字符串数组进行映射

## 50

**题目描述**

x 的 n 次方

**解题思路**

1. 递归
    - 折半计算，每次把 n 缩小一半
    - 如果 n 是偶数，直接把上次递归得到的值算个平方返回即可
    - 如果 n 是奇数，则还需要乘上个 x 的值
    - 如果 n 是 -1，返回 x 的倒数
    - 如果 n 是 0，返回 1

## 51

**题目描述**

N 皇后问题。NxN 的棋盘上放置 N 个皇后，不能在同一行同一列同一斜线上。返回所有可能的解法。

**解题思路**

1. 递归回溯。
    - 1 维棋盘只需要放置 1 个皇后
    - 二维三维棋盘无解
    - 针对四维以上的棋盘，调用递归
      - 首先判断当前行数是否已经为 n，如果是说明结果有效
      - 尝试在新的一行中放置皇后，检查其有效性
      - 如果有效，递归下一行

## 52

**题目描述**

N 皇后问题。NxN 的棋盘上放置 N 个皇后，不能在同一行同一列同一对角线上。返回可行解数量。

**解题思路**

1. 递归回溯

## 53

**题目描述**

求最大子数组之和

**解题思路**

1. 动态规划，复杂度为 O(n)。
   - dp[i] 表示以位置 i 为结尾的子数列的最大和。
   - [最大子数列问题 - 维基百科，自由的百科全书](https://zh.wikipedia.org/wiki/%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E5%88%97%E9%97%AE%E9%A2%98)
2. 分治法，复杂度为 O(nlgn)。
   - 把数组一分为二，分别找出左边和右边的最大子数组之和，然后还要从中间开始向左右分别扫描，求出的最大值分别和左右两边得出的最大值相比较取最大的那一个

## 54

**题目描述**

打印螺旋数组(顺时针螺旋)

**解题思路**

1. 从外向内逐层打印。需要四个变量记录上下左右的边界。
2. 迷宫遍历。定义四个方向矢量，走到边界或者已经走过的位置转变方向。
3. 迷宫遍历优化：由于原数组中不会有 0，所以就可以将访问过的位置标记为 0。

## 55

**题目描述**

给定一个非负整数的数组，每个数字表示在当前位置的最大跳力（这里的跳力指的是在当前位置为基础上能到达的最远位置），求判断能不能到达最后一个位置。

**解题思路**

1. 贪心算法：用一个变量标记当前能达到的最远距离。遍历数组，若超过超远距离或者最远距离已经覆盖数组尾退出循环，否则更新最远距离。

## 56

**题目描述**

合并区间

**解题思路**

1. 排序
   - 给区间集排序，按照 start 的值从小到大来排序，排完序开始合并
   - 首先把第一个区间存入结果中，然后从第二个开始遍历区间集，如果结果中最后一个区间和遍历的当前区间无重叠，直接将当前区间存入结果中
   - 如果有重叠，将结果中最后一个区间的 end 值更新为结果中最后一个区间的 end 和当前 end 值之中的较大值，然后继续遍历区间集，以此类推可以得到最终结果

## 57

**题目描述**

在列表中插入一个新的区间，需要确保列表中的区间仍然有序且不重叠（如果有必要的话，可以合并区间）。

**解题思路**

1. 从最左边遍历待插入区间，如果遍历区间右边界小于新区间左边界，将遍历区间加入结果，否则跳出循环。然后正式对交叉的区间进行处理，注意每次处理前都要判断是否重叠（因为有可能出现新区建在最左边和最右边的情况），然后取左边界最小值和右边界最大值作为新区间。不重叠时候跳出循环，将新区间加入结果，最后把剩下的待插入区间遍历完即可，所以有三个阶段。
2. 上述方法的进一步简化：合并原列表中所有与新区间交叉重叠的区间，最后再把该区间插入到结果列表中。

**边界条件**

1. 待插列表为空；
2. 新区间在最左边或者最右边；
3. 插入区间为空

## 58

**题目描述**

返回字符串中最后一个单词的长度

**解题思路**

undefined

## 59

**题目描述**

构建螺旋数组。

**解题思路**

1. 可以发现顺时针走法是按照 [ '→', '↓', '←', '↑', ] 的顺序转向，当走出边缘或者碰到已经填上的数字时候就会转向。注意转向函数的书写，和常识不同。

## 60

**题目描述**

n 个数字的第 k 个排列组合

**解题思路**

1. 从高位到低位逐个确定。以首位为例，每个数字出现的概率是均等的，而且在序列里会连续出现。n 个数字有 n! 个排列， 1~(n-1)! 位的首位都是1，以此类推。

## 61

**题目描述**

旋转链表

**解题思路**

1. 遍历整个链表获得链表长度n，然后此时把链表头和尾链接起来，在往后走 $n - k % n$ 个节点就到达新链表的头结点前一个点，这时断开链表

**边界条件**:

1. 空链表
2. k大于链表长度

## 62

**题目描述**

从左上角走到右下角所有不同走法的个数

**解题思路**

1. 动态规划
    - $dp[i][j]$ 表示到当前位置不同的走法的个数
    - $dp[i][j] = dp[i - 1][j] + dp[i][j - 1]$，i == 0 || j == 0 时 $dp[i][j] = 1$
    - 为了节省空间，可以使用一维数组 dp，一行一行地刷新
2. 组合数学
    - 实际相当于机器人总共走了 m + n - 2步，其中 m - 1 步向右走，n - 1 步向下走

## 63

**题目描述**

从左上角到右下角不同行走路径的个数，而且有些位置有障碍物

**解题思路**

1. 动态规划
    - $dp[i][j]$ 表示到当前位置不同的走法的个数
    - $dp[i][j] = dp[i - 1][j] + dp[i][j - 1]$，i == 0 || j == 0 时 $dp[i][j] = 1$
    - 如果当前位置存在障碍物，$dp[i][j] = 0$
    - 为了节省空间，可以使用一维数组 dp，一行一行地刷新

## 64

**题目描述**

给定一个只有非负数的二维数组，让找一条从左上到右下的路径，使得路径和最小，限定了每次只能向下或者向右移动。

**解题思路**

1. 动态规划:
   - 使用一个一维的 dp 数组，初始化为整型最大值，dp[0][0] 要初始化为0
   - 若 j 等于 0 时，说明是第一列，直接加上当前的数字

## 65

**题目描述**

验证数字有效性。

**解题思路**

1. 状态转移。注意要在字符串后面加一个空格表示结束符，从而使得终结符号只有 1 个。
2. TODO

**边界条件**

1. 数字字符串中间不能被空格打断；不能出现两个以上数字字符串；
2. “1.”是合法的；“.1”合法；“.”不合法；
3. “+.5”合法；
4. “0000.1e-0000.00”合法；

## 66

**题目描述**

数字以数组形式存在，+1 返回

**解题思路**

undefined

## 67

**题目描述**

二进制数相加，结果保存在 string 中

**解题思路**

undefined

## 68

**题目描述**

给定一个字符数组，和一个行的最大长度。将单词放入行内，同一行相邻的单词中间需要有空格。当放入一个单词后该行长度大于最大长度，那么这个单词就不能放入该行，需要另起一行。这样的话，行的长度就可能会小于最大长度，于是需要增加单词间的空格数量，尽可能均匀的分配，若不能均匀分配，那么左边的单词数量应该大于右边。

**解题思路**

1. 遍历单词 list, 并维护一个cur_len表示当前收纳的长度（需包含空格）。每读入一个单词有三种情况：
   - 加入当前单词后，cur_len <= maxWidth，当前单词记录，遍历下一个单词
   - 加入当前单词后，cur_len >= maxWidth 而且当前单词不是最后一个单词。此时将记录的单词串格式化处理。
   - 当前单词是最后一个单词，将记录的单词串格式化处理。（因为最后一行格式特殊）

## 69

**题目描述**

返回给定数的平方根(小数部分截断)

**解题思路**

1. 牛顿迭代法：求 $x^2 = n$ 的解，令 $f(x)=x^2-n$，相当于求 $f(x)=0$ 的解。

## 70

**题目描述**

爬梯子问题，每次只能 1 或 2 步，爬到第 n 层的总方案数

**解题思路**

1. 动态规划: 斐波那契数列变种，a,b->b,a+b，只用两个整型变量 a 和 b 来存储过程值，首先将 a+b 的值赋给 b，然后 a 赋值为原来的 b。

## 71

**题目描述**

简化路径

**解题思路**

undefined

**边界条件**:

1. "/../" 返回 “/”
2. "/home//foo/" 返回 "/home/foo"

## 72

**题目描述**

在信息论、语言学和计算机科学领域，Levenshtein Distance 是用来度量两个序列相似程度的指标。通俗地来讲，编辑距离指的是在两个单词之间，由其中一个单词转换为另一个单词所需要的最少单字符编辑操作次数。

在这里定义的单字符编辑操作有且仅有三种：

- 插入（Insertion）
- 删除（Deletion）
- 替换（Substitution）

譬如，"kitten" 和 "sitting" 这两个单词，由 "kitten" 转换为 "sitting" 需要的最少单字符编辑操作有：
(1) kitten → sitten (substitution of "s" for "k")
(2) sitten → sittin (substitution of "i" for "e")
(3) sittin → sitting (insertion of "g" at the end)
因此，"kitten" 和 "sitting" 这两个单词之间的编辑距离为 3 。

将两个字符串 a, b 的 Levenshtein Distance 表示为 $lev_{a,b}(|a|, |b|)$，其中 $|a|$ 和 $|b|$ 分别对应 a, b 的长度。那么，在这里两个字符串 a, b 的 Levenshtein Distance，即 $lev_{a,b}(|a|, |b|)$ 可用如下的数学语言描述：

![Levenshtein Distance 数学描述](https://gitlab.com/convexwf/convex-resource/-/raw/master/convex-notes/leetcode-Levenshtein_Distance_数学描述.png)

定义 $lev_{a,b}(i, j)$ 指的是 a 中前 i 个字符和 b 中前 j 个字符之间的距离。

当 $min(i, j) = 0$ 的时候，对应着字符串 a 中前 i 个字符和字符串 b 中前 j 个字符，此时的 i, j 有一个值为 0，表示字符串 a 和 b 中有一个为空串，那么从 a 转换到 b 只需要进行 $max(i, j)$ 次单字符编辑操作即可，所以它们之间的编辑距离为 $max(i, j)$。

当 $min(i, j) \ne 0$ 的时候，$lev_{a,b}(i, j)$ 为如下三种情况的最小值：
(1) $lev_{a,b}(i-1, j) + 1$ 表示 删除 $a_i$
(2) $lev_{a,b}(i, j-1) + 1$ 表示 插入 $b_j$
(3) $lev_{a,b}(i-1, j-1)+1_{(a_i \ne b_j)}$ 表示 替换 $b_j$

$1_{(a_i \ne b_j)}$ 为一个指示函数，表示当 $a_i = b_j$ 的时候取 0；当 $a_i \ne b_j$ 的时候，其值为 1。

**解题思路**

1. 动态规划。
2. 动态规划，简化空间复杂度。

## 73

**题目描述**

给定一个矩阵，如果一个元素为 0，则将其整个行和列设置为 0。要求 in-place 空间复杂度。

**解题思路**

1. 用原数组的第一行第一列来记录各行各列是否有 0。
   - 先扫描第一行第一列，如果有0，则将各自的flag设置为true
   - 然后扫描除去第一行第一列的整个数组，如果有0，则将对应的第一行和第一列的数字赋0
   - 再次遍历除去第一行第一列的整个数组，如果对应的第一行和第一列的数字有一个为0，则将当前值赋0
   - 最后根据第一行第一列的flag来更新第一行第一列

## 74

**题目描述**

搜索 2D 矩阵: 每行中的整数从左到右排序。每行的第一个整数大于前一行的最后一个整数。

**解题思路**

1. 将二维数组展开为一个有序的一维数组，只需要用一次二分查找法，而关键就在于坐标的转换。
2. 双指针: 从右上角开始验证，假如这个数字等于 target，直接返回 true；若大于 target，说明要减小数字，则列数自减 1；若小于 target，说明要增加数字，行数自增1
3. 在第一列上先用一次二分查找法找到目标值所在的行的位置
    - 问题转换为查找第一个大于目标值的数，只要将返回值-1就能得出目标值的行。
    - 在目标行再执行一次二分搜索

## 75

**题目描述**

数组中只有 0，1，2 三种元素，排序

**解题思路**

1. 双指针: 头指针指向开头，尾指针指向末尾。从头开始遍历原数组，
   - 如果遇到 0，则交换该值和头指针指向的值，并将头指针后移一位。交换后的值可能为 0,1
   - 若遇到 2，则交换该值和尾指针指向的值，并将尾指针前移一位。交换后的值可能为 0,1,2
   - 若遇到 1，则继续遍历。

## 76

**题目描述**

最小覆盖子串，在字符串 S 里面找出包含 T 所有字母的最小子串。

**解题思路**

1. 滑动窗口 + HashMap
   - 只用一个哈希表存储 t 的频率。
   - 另外需要一个计数变量，当频率大于 0 时（因为非法字符最大频率为 0，合法字符最小频率为 0）计数变量 cnt 加 1，从而可以判断是否已经包含所有合法字符。
   - 没有必要每次都计算子串，只要有了起始位置和长度，就能唯一确定一个子串。这里使用一个全局变量 minLeft 来记录最终结果子串的起始位置。

**边界条件**

1. t 长度可能为 0

## 77

**题目描述**

1 到 n 共 n 个数字里 k 个数的组合数的所有情况

**解题思路**

1. 深度优先搜索 DFS
2. 子问题分解: $ C(n, k) = C(n-1, k-1) + C(n-1, k) $，在 n 个数中取 k 个数的组合项个数，等于在 n-1 个数中取 k-1 个数的组合项个数再加上在 n-1 个数中取 k 个数的组合项个数之和。
3. 迭代: 每次先递增最右边的数字，存入结果 res 中，当右边的数字超过了n，则增加其左边的数字，然后将当前数组赋值为左边的数字，再逐个递增，直到最左边的数字也超过了n，停止循环。

## 78

**题目描述**

找出给定集合的所有子集，输入数组没有重复项。

**解题思路**

以 [1,2,3] 为例

1. 非递归遍历: 按照子集的长度由少到多全部写出来，添加顺序为 [], [1], [2], [1 2], [3], [1 3], [2 3], [1 2 3]
2. DFS 深度优先搜索: 原集合每一个数字只有两种状态，要么存在，要么不存在，那么在构造子集时就有选择和不选择两种情况
3. 位操作：数组中所有的数分配一个状态，true 表示这个数在子集中出现，false 表示在子集中不出现，那么对于一个长度为n的数组，每个数字都有出现与不出现两种情况，所以共有 $2^n$ 种情况。

    | **集合** | **整数** | **A是否出现** | **B是否出现** | **C是否出现** |
    | -------- | -------- | ------------- | ------------- | ------------- |
    | {}       | 000=0    | 100&000=0     | 010&000=0     | 001&000=0     |
    | {C}      | 001=1    | 100&001=0     | 010&001=0     | 001&001=1     |
    | {B}      | 010=2    | 100&010=0     | 010&010=1     | 001&010=0     |
    | {B,C}    | 011=3    | 100&011=0     | 010&011=1     | 001&011=1     |
    | {A}      | 100=4    | 100&100=1     | 010&100=0     | 001&100=0     |
    | {A,C}    | 101=5    | 100&101=1     | 010&101=0     | 001&101=1     |
    | {A,B}    | 110=6    | 100&110=1     | 010&110=1     | 001&110=0     |
    | {A,B,C}  | 111=7    | 100&111=1     | 010&111=1     | 001&111=1     |

## 79

**题目描述**

给定一个 m x n 二维字符网格 board 和一个字符串单词 word。如果 word 存在于网格中，返回 true；否则，返回 false。

**解题思路**

1. DFS：以二维数组中每一个数都作为起点和给定字符串做匹配，并且需要一个 visited 数组用来记录当前位置是否已经被访问过。如果二维数组 board 的当前字符和目标字符串 word 对应的字符相等，则对其上下左右四个邻字符分别调用 DFS 的递归函数，只要有一个返回 true，那么就表示可以找到对应的字符串，否则就不能找到。

## 80

**题目描述**

排序数组去除重复数字，重复数字最多存在两个

**解题思路**

1. 快慢指针
   - 用一个变量 cnt 来记录还允许有几次重复，cnt 初始化为1，如果出现过一次重复，则 cnt 递增1，如果不是重复的，则 cnt 恢复1
   - 由于整个数组是有序的，所以一旦出现不重复的数，则一定比这个数大，此数之后不会再有重复项。
2. 数字 num 只要跟上个覆盖位置的数字 nums[i-2] 比较，若 num 较大，则绝不会出现第三个重复数字

## 81

**题目描述**

在旋转数组中搜索一个给定值，返回坐标，若不存在返回 -1，数组中*有*重复值。

**解题思路**

1. 二分搜索，参见 <33. Search in Rotated Sorted Array>
   - 如果出现重复值，把最右值向左一位即可继续循环，如果还相同则继续移，直到移到不同值为止

## 82

**题目描述**

给定一个已排序的链表，删除所有具有重复数字的节点，1-2-2-3 返回 1-3

**解题思路**

1. 迭代+dummy 节点:
   - 定义一个前驱指针和一个现指针
   - 每当前驱指针指向新建的节点，现指针从下一个位置开始往下遍历，遇到相同的则继续往下，直到遇到不同项时，把前驱指针的next指向下面那个不同的元素。
   - 如果现指针遍历的第一个元素就不相同，则把前驱指针向下移一位
2. 递归
   - 连续删除和当前节点值相等的下个节点，然后返回 next 指针
   - 如果没有删除节点，返回当前节点

**边界条件**

1. 空链表
2. 只有 1 个元素的链表

## 83

**题目描述**

移除给定有序链表的重复项，只留下一个

**解题思路**

1. 迭代
2. 递归

## 84

**题目描述**

求直方图中最大的矩形。

**解题思路**

1. 遍历数组，每找到一个局部峰值（只要当前的数字大于后面的一个数字，那么当前数字就看作一个局部峰值，跟前面的数字大小无关），然后向前遍历所有的值，算出共同的矩形面积，每次对比保留最大值。
2. 单调递增栈，原理同样是找局部峰值
   - 当遇到大的数字直接进栈，而当遇到小于栈顶元素的数字时，就要取出栈顶元素进行处理
   - 为了使得最后一块板子也被处理，在高度数组最后面加上一个0
   - 计算面积时，先取出栈中最高的板子，那么就可以先算出长度为1的矩形面积了，然后再取下一个板子，此时根据矮板子的高度算长度为2的矩形面积，以此类推，知道数字大于栈顶元素为止，再次进栈
   - [LeetCode Monotone Stack Summary 单调栈小结 - Grandyang - 博客园](https://www.cnblogs.com/grandyang/p/8887985.html)

## 85

**题目描述**

给定一个仅包含 0 和 1 的二维二进制矩阵，找出只包含 1 的最大矩形，并返回其面积。

**解题思路**

1. 先确定高度和宽度再得到最大面积
   - 维护三个数组（左连续序列长度、右连续序列长度、高度）
   - 左连续序列长度：指从左边开始计数到当前位置，连续的高于当前高度的序列长度（包括当前位置）
   - 右连续序列长度：指从右边开始计数到当前位置，连续的高于当前高度的序列长度（包括当前位置）
   - 进行行遍历，若当前位置为 "1"，要考虑上一侧行遍历序列长度是否大于 0。如果大于 0 说明正上面位置为 "1"，则取连续的行 "1" 长度和上一次序列遍历长度的最小值，否则，直接认为序列长度为连续的行 "1" 长度；若当前位置为 "0"，序列长度直接置 0。
2. 统计每一行的连续 1 的个数
   - 使用一个数组 h_max, 其中 `h_max[i][j]` 表示第 i 行，第 j 个位置水平方向连续 1 的个数，若 `matrix[i][j]` 为 0，那对应的 `h_max[i][j]` 也一定为 0。
   - 统计的过程跟建立累加和数组很类似，唯一不同的是遇到 0 了要将 h_max 置 0。
   - 统计完成之后，只需要再次遍历每个位置，首先每个位置的 h_max 值都先用来更新结果 res，因为高度为 1 也可以看作是矩形，然后我们向上方遍历，上方 (i, j-1) 位置也会有 h_max 值，但是用二者之间的较小值才能构成矩形，用新的矩形面积来更新结果 res，这样一直向上遍历，直到遇到 0，或者是越界的时候停止，这样就可以找出所有的矩形

**边界条件**

1. 矩阵为空

## 86

**题目描述**

划分链表，把所有小于给定值的节点都移到前面，大于该值的节点顺序不变。

**解题思路**

1. 首先找到第一个大于或等于给定值的节点，然后将所有小于给定值的节点置于该节点之前即可。
2. 将所有小于给定值的节点取出组成一个新的链表，此时原链表中剩余的节点的值都大于或等于给定值，只要将原链表直接接在新链表后。

## 88

**题目描述**

合并两个有序数组。

**解题思路**

1. 从后往前插入混合数组
   - 需要三个变量，分别指向 nums1，nums2，和混合数组的末尾。
   - 循环结束后，有可能 i 或者 j 还大于等于 0，若 j 大于 0，那么还需要继续循环，将 nums2 中的数字继续拷入 nums1。
   - 若是 i 大于等于 0，那么就不用管，因为混合数组本身就放在 nums1 中。
2. 将两个 while 循环融合到一起，只要加上 `i >= 0` 且 `nums1[i] > nums2[j]` 的判断条件，就可以从 nums1 中取数，否则就一直从 nums2 中取数。

## 89

**题目描述**

格雷码是一种循环二进制单位距离码，主要特点是两个相邻数的代码只有一位二进制数不同的编码。给定正整数 n，返回由 n 个 bit 组成的格雷码系统。

```txt
Int    Gray Code    Binary
 0  　　  000        000
 1  　　  001        001
 2   　 　011        010
 3   　 　010        011
 4   　 　110        100
 5   　 　111        101
 6   　 　101        110
 7   　　 100        111
```

**解题思路**

1. 格雷码和二进制相互转换
   - 二进制转格雷码：二进制数右移一位和原来的数按位取异或。
   - 格雷码转二进制：需要使用一个循环来转换，首先最高位不变B[i]=G[i],次高位=二进制的高位与格雷码次高位高位取异或即B[i-1]=B[i]^G[i-1],直到i<0.
2. 镜面排列: n 位元的格雷码可以从 n-1 位元的格雷码以上下镜射后加上新位元的方式快速得到。

   ```txt
   n = 1    n = 2       n = 3
   0        00          000
   1        01          001
            11          011
            10          010
                        100
                        101
                        111
                        110
   ```

3. 直接排列：以二进制为 0 值的格雷码为第零项，第一项改变最右边的位元，第二项改变右起第一个为1的位元的左边位元，第三、四项方法同第一、二项，如此反复，即可排列出n个位元的格雷码。

   ```txt
   0 0 0
   0 0 1
   0 1 1
   0 1 0
   1 1 0
   1 1 1
   1 0 1
   1 0 0
   ```

4. HashSet：从 0 开始，遍历其二进制每一位，对其取反，然后看其是否在 HashSet 中出现过，如果没有，我们将其加入 HashSet 和结果 res 中，然后再对这个数的每一位进行遍历，以此类推就可以找出所有的格雷码了。

## 90

**题目描述**

找出给定集合的所有子集，输入数组允许有重复项。

**解题思路**

1. 非递归遍历: 按照子集的长度由少到多全部写出来。用 last 来记录上一个处理的数字，然后判定当前的数字和 last 是否相同，若不同，则循环还是从 0 到当前子集的个数，若相同，则新子集个数减去之前循环时子集的个数当做起点来循环，这样就不会产生重复。
2. DFS：增加去重处理。

## 92

**题目描述**

倒置链表中的某一小段

**解题思路**

1. 找到第一个开始变换结点的前一个结点，然后进行 n - m 次交换即可。

## 93

**题目描述**

复原 IP 地址

**解题思路**

1. 递归，从某一位开始，连续截取1位、2位或者3位数字，然后将后续数字进行递归处理。
2. 方法 1 的进一步优化
3. 暴力搜索
   - 每段数字最多只能有三位，而且只能分为四段
   - 每一段都循环 1 到 3，然后当 4 段位数之和等于原字符串长度时，进一步判断每段数字是否不大于255，然后滤去不合要求的数字，加入结果中即可

**边界条件**

1. IP地址要去除前导0。"010010"注意不能转化为"0.1.0.10"
2. 长度小于4或者大于12

## 94

**题目描述**

实现二叉树的中序遍历。

**解题思路**

1. 递归
2. 迭代+栈+辅助节点
3. Morris 遍历：O(1) 空间复杂度。构建一个线索二叉树，需要将所有为空的右子节点指向中序遍历的下一个节点，这样中序遍历完左子结点后，就能顺利的回到其根节点继续遍历了。具体算法如下：
   - (1) 初始化指针 cur 指向 root
   - (2) 当 cur 不为空时，如果 cur 没有左子结点，打印出 cur 的值，将 cur 指针指向其右子节点
   - (3) 如果 cur 有左子结点，将 pre 指针指向 cur 的左子树中的最右子节点。
     - 若 pre 不存在右子节点，将其右子节点指回 cur，cur 指向其左子节点。
     - 若 pre 存在右子节点，将 pre 的右子节点置空，打印 cur 的值，将 cur 指针指向其右子节点

## 95

**题目描述**

给定一个整数，表示为节点数目，给出所有二叉搜索树的组成。

**解题思路**

1. 递归：选定一个pivot后，比pivot小的交给左子树，比pivot大的交给右子树，递归形式是最后回收所有可能的子树形式。
2. 递归+记忆数组：`memo[i][j]` 表示在区间 [i, j] 范围内可以生成的所有 BST 的根结点，这样在递归函数中，就可以去 memo 中查找当前的区间是否已经计算过。

## 96

**题目描述**

给定一个整数，表示为节点数目，有几种二分搜索树的组合。

**解题思路**

```txt
n = 0  空树  dp[0] = 0
n = 1  左子树个数乘以右子树的个数，左右子树都是空树  dp[1] = 1 * 1 = 1
n = 2  dp[2] = dp[0] * dp[1]　　(1 为根的情况，则左子树一定不存在，右子树可以有一个数字)
             + dp[1] * dp[0]　　(2 为根的情况，则左子树可以有一个数字，右子树一定不存在)
n = 3  dp[3] = dp[0] * dp[2]　　(1 为根的情况，则左子树一定不存在，右子树可以有两个数字)
             + dp[1] * dp[1]　　(2 为根的情况，则左右子树都可以各有一个数字)
             + dp[2] * dp[0]　　(3 为根的情况，则左子树可以有两个数字，右子树一定不存在)
......
dp[n] = dp[0] * dp[n-1] + dp[1] * dp[n-2] + + ... + dp[n-1] * dp[0]
```

[卡塔兰数 - 维基百科，自由的百科全书](https://zh.wikipedia.org/wiki/%E5%8D%A1%E5%A1%94%E5%85%B0%E6%95%B0)

1. 卡特兰数的递推式：$C_0=1 \quad \text { and } \quad C_{n+1}=\sum_{i=0}^n C_i C_{n-i} \quad \text { for } n \geq 0$
2. 卡特兰数的通项公式： $\frac{C_{2n}^{n}}{n+1}$

**边界条件**

1. 相乘的时候为了防止整型数溢出，要将结果 res 定义为长整型。

## 97

**题目描述**

给定字符串 s1，s2 和 s3，问 s3 是不是由 s1 和 s2 交织组成。

**解题思路**

1. 动态规划
   - 前提：字符串 s1 和 s2 的长度和必须等于 s3 的长度
   - 初始化：若 s1 和 s2 其中的一个为空串的话，那么另一个肯定和 s3 的长度相等，则按位比较
   - 在任意非边缘位置 `dp[i][j]` 时，它的左边或上边有可能为 True 或是 False，两边都可以更新过来，只要有一条路通着，那么这个点就可以为 True
   - 转移方程：`dp[i][j] = (dp[i - 1][j] && s1[i - 1] == s3[i - 1 + j]) || (dp[i][j - 1] && s2[j - 1] == s3[j - 1 + i])`;
2. DFS + HashSet
   - 分别用变量i，j，和k来记录字符串 s1，s2，和 s3 匹配到的位置，初始化的时候都传入0。
   - 在递归函数中，首先根据 i 和 j 算出 key 值，如果 key 已经在集合中，直接返回 false，因为集合中存的是无法匹配的情况。
   - corner case：如果 i 等于 s1 的长度了，说明 s1 的字符都匹配完了，此时 s2 剩下的字符和 s3 剩下的字符可以直接进行匹配。同理，如果 j 等于 s2 的长度了，说明 s2 的字符都匹配完了，此时 s1 剩下的字符和 s3 剩下的字符可以直接进行匹配。
   - 如果 s1 和 s2 都有剩余字符，那么当 s1 的当前字符等于 s3 的当前字符，那么调用递归函数，注意 i 和 k 都加上 1，如果递归函数返回 true，则当前函数也返回 true；还有一种情况是，当 s2 的当前字符等于 s3 的当前字符，那么调用递归函数，注意 j 和 k 都加上 1，如果递归函数返回 true，那么当前函数也返回 true。
   - 如果匹配失败了，则将 key 加入集合中，并返回 false 即可

**边界条件**

1. s1 或者 s2 为空

## 98

**题目描述**

验证是否为二叉搜索树。

**解题思路**

1. 中序递归遍历：针对每一颗子树逐步收缩区间，该方法只能解决严格不等于情况的二叉搜索树，无法处理 左<=根<=右 的情况。
2. 中序遍历 + 排序：通过中序遍历将所有的节点值存到一个数组里，再来判断这个数组是不是有序。
3. 中序遍历：每当遍历到一个新节点时和其上一个节点比较。
4. 迭代中序遍历：Morris 遍历。

**边界条件**

1. 根节点中出现 INT_MAX 和 INT_MIN

## 99

**题目描述**

复原一个二叉搜索树，其中有两个节点的值被交换了

**解题思路**

1. 中序遍历：通过中序遍历拿到BST的升序排列（同时拿到对应的指针），把升序排列重新排序后重新复制。O(nlogn) 时间复杂度，O(n) 空间复杂度。
2.

## 100

**题目描述**

判断两棵树是否相同

**解题思路**

1. 递归先序遍历
2. 非递归先序遍历+栈
3. 非递归中序遍历+栈

## 102

**题目描述**

层序遍历

**解题思路**

1. 递归
2. 迭代: 队列

## 103

**题目描述**

二叉树的之字形层序遍历。

**解题思路**

1. 先序遍历：用一个变量 level 记录当前的深度，由于 level 是从 0 开始的，假如结果 res 的大小等于 level，就需要在结果 res 中新加一个空集，这样可以保证 res[level] 不会越界。取出 res[level] 之后，判断 level 的奇偶，若其为偶数，则将 node->val 加入 oneLevel 的末尾，若为奇数，则加在 oneLevel 的开头，然后分别对 node 的左右子结点调用递归函数。
2. 层序遍历+队列

## 104

**题目描述**

二叉树的最大深度

**解题思路**

1. DFS
2. BFS

## 105

**题目描述**

前序遍历+中序遍历，构建二叉树

**解题思路**

1. 分治法
   - 先序遍历的第一个元素是根，结合中序遍历可以对左右子树分别处理

## 106

**题目描述**

中序遍历+后序遍历，构建二叉树

**解题思路**

1. 分治法
   - 后序遍历的最后一个元素是根，结合中序遍历可以对左右子树分别处理

## 107

**题目描述**

层序遍历(自底向上)

**解题思路**

1. 递归：使用一个变量标记当前深度
2. 迭代

## 108

**题目描述**

有序数组转为二叉搜索树。

**解题思路**

1. 二分查找：根节点应该是有序数组的中间点，从中间点分开为左右两个有序数组。

## 109

**题目描述**

有序链表转为二叉搜索树。

**解题思路**

1. 递归，通过双指针法找到链表中心，然后一切为二，分别建立左子树和右子树。
2. 递归：在一个函数内完成。

## 110

**题目描述**

判断平衡二叉树，平衡二叉树是每一个结点的两个子树的深度差不能超过 1。

**解题思路**

1. 递归获得左右子树的深度，如果子树是平衡的，则返回真实的深度，若不平衡，直接返回 -1，此方法时间复杂度 O(N)，空间复杂度 O(H)。

## 111

**题目描述**

二叉树的最小深度。

**解题思路**

1. 递归：首先判空，若当前结点不存在，直接返回 0。若左子结点不存在，那么对右子结点调用递归函数，并加 1 返回。反之，若右子结点不存在，那么对左子结点调用递归函数，并加 1 返回。最后分别对左右子结点调用递归函数，将二者中的较小值加 1 返回即可。
2. 迭代：层序遍历，记录遍历的层数，一旦遍历到第一个叶结点，就将当前层数返回，即为二叉树的最小深度。

## 112

**题目描述**

是否存在根点路径(从根节点到叶子节点)和等于给定值。

**解题思路**

1. 树递归: 遍历每一条完整的路径。需要判断节点是叶子节点还是普通的路径点。

## 113

**题目描述**

找出路径和等于给定值的所有根点路径(从根节点到叶子节点)

**解题思路**

1. 递归遍历: 每当 DFS 搜索到新结点时，都要保存该结点。而且每当找出一条路径之后，都将这个保存为一维 vector 的路径保存到最终结果二维 vector 中。

## 114

**题目描述**

把二叉树展开成链表

**解题思路**

1. 递归：利用 DFS 的思路找到最左子节点，然后回到其父节点，把其父节点和右子节点断开，将原左子结点连上父节点的右子节点上，然后再把原右子节点连到新右子节点的右子节点上，然后再回到上一父节点做相同操作。
2. 迭代：从根节点开始出发，先检测其左子结点是否存在，如存在则将根节点和其右子节点断开，将左子结点及其后面所有结构一起连到原右子节点的位置，把原右子节点连到原左子结点最后面的右子节点之后。

## 115

**题目描述**

给定字符串 S 和 T，从 S 中选择子序列使得刚好和 T 相等，有多少种选法。

**解题思路**

1. 动态规划：`dp[i][j]` 表示 s 中范围是 [0, i] 的子串中能组成 t 中范围是 [0, j] 的子串的子序列的个数。状态转移方程为 `dp[i][j] = dp[i][j - 1] + (T[i - 1] == S[j - 1] ? dp[i - 1][j - 1] : 0)`。
2. 动态规划：简化用一维数组

```txt
  Ø r a b b b i t
Ø 1 1 1 1 1 1 1 1
r 0 1 1 1 1 1 1 1
a 0 0 1 1 1 1 1 1
b 0 0 0 1 2 3 3 3
b 0 0 0 0 1 3 3 3
i 0 0 0 0 0 0 3 3
t 0 0 0 0 0 0 0 3
```

**边界条件**

1. 空串是任意字符串（包括空串）的子串，在本题中空串仅计算1次。
2. 非空串不是空串的子串。
3. 数据类型不能使用 int，因为在运算过程中有可能会出现比最终结果大的数字（比如说rab能够比rabbit匹配更多次）而导致溢出。

## 116

**题目描述**

连接完美二叉树中的相邻节点

**解题思路**

1. 递归前序遍历
   - 每个节点都要负责解决左子节点和右子节点的 next 指针指向。
   - 因为是完全二叉树，所以左节点可以直接指向右节点；
   - 右子节点的处理方法是，判断其父节点的 next 是否为空，若不为空，则指向其 next 指针指向的节点的左子结点，若为空则指向 NULL
2. 非递归层序遍历：用两个指针 start 和 cur，其中 start 标记每一层的起始节点，cur 用来遍历该层的节点

## 117

**题目描述**

普通二叉树连接相邻节点，要求不使用额外空间。

**解题思路**

1. 迭代遍历+队列：每层的节点都按顺序加入 queue 中，而每当从 queue 中取出一个元素时，将其 next 指针指向 queue 中下一个节点，对于每层的开头元素开始遍历之前，先统计一下该层的总个数，当 for 循环结束的时候，该层就已经被遍历完了。空间复杂度不为 O(1)！
2. 递归：由于子树有可能残缺，故需要平行扫描父节点同层的节点，找到他们的左右子节点。
3. 迭代，O(1)空间复杂度
   - 建立一个 dummy 结点来指向每层的首结点的前一个结点，然后指针cur用来遍历这一层
   - 首先cur指向dummy，然后cur再连上root下一层的首结点，这样dummy也就连上了。然后当root层遍历完了之后，root需要往下移动一层，这样dummy结点之后连接的位置就正好赋值给root，然后cur再指向dummy，dummy之后断开，这样又回到了初始状态，以此往复就可以都连上了。

## 118

**题目描述**

构造杨辉三角(帕斯卡三角)

**解题思路**

## 119

**题目描述**

杨辉三角的第 n 层(n + 1行)，规定 O(n) 空间复杂度

杨辉三角主要有下列五条性质：

1. 杨辉三角以正整数构成，数字左右对称，每行由 1 开始逐渐变大，然后变小，回到 1。
2. 第 n 行的数字个数为 n 个。
3. 第 n 行的第 k 个数字为组合数 $C_{n-1}^{k-1}$。
4. 第 n 行数字和为 $2^{n-1}$。
5. 除每行最左侧与最右侧的数字以外，每个数字等于它的左上方与右上方两个数字之和（也就是说，第n行第k个数字等于第 n-1 行的第 k-1 个数字与第k个数字的和）。这是因为有组合恒等式：$C_{n}^{i}=C_{n-1}^{i-1}+C_{n-1}^{i}$。可用此性质写出整个杨辉三角形。

**解题思路**

1. 利用杨辉三角的第三条性质: 可以递归写出同一行的下一个数字。

## 120

**题目描述**

三角形从上到下最小路径和，要求 O(n) 空间复杂度

**解题思路**

1. 动态规划: 转化思维，从下往上走。
   - 复制三角形最后一行，作为用来更新的一位数组。
   - 然后逐个遍历这个DP数组，对于每个数字，和它之后的元素比较选择较小的再加上面一行相邻位置的元素做为新的元素，然后一层一层的向上扫描

## 121

**题目描述**

卖卖股票，买进前必须卖出手头已有的，只允许一次交易

**解题思路**

1. 遍历每天的股价，存储遍历到当前位置的最小值，然后用当前值减去最小值即可得到如果当天卖出得到最大的利润。注意利润值可能为负数，这时候可以不交易保证不亏本（即返回最小为0）。

## 122

**题目描述**

买卖股票，买进前必须卖出手头已有的；允许无数次交易

**解题思路**

1. 只要前后两数呈递增关系，则可以进行交易。

## 123

**题目描述**

股票交易，买进前必须卖出手头已有的，允许最多两次交易。

**解题思路**

1. 在数组中间画条线，在左边进行第一次交易，在右边进行第二次交易，来计算两次交易的最大收益和。这样，就将问题简化为只进行一次交易的问题了。维护两个数组，分别存储截止到第 x 日交易的最大利润和第 x 日之后交易的最大利润。

## 124

**题目描述**

非空二叉树最大路径和，路径至少经过一个节点，路径不一定经过根节点和叶子节点。

**解题思路**

1. 递归
   - 如果当前结点不存在，直接返回 0
   - 否则就分别对其左右子节点调用递归函数。由于（左右子节点）路径和有可能为负数，所以要和 0 相比较大值，即要么不加，加就要加正数。
   - 然后通过求和 左路径和 + 右路径和 + 当前节点值 来更新全局最大值结果 res

**Follow up**

1. 返回和最大的路径

## 125

**题目描述**

验证一个给定的字符串是否为回文。有效字符值包含字母和数字，其他视作跳过。

**解题思路**

1. 分别从字符的开头和结尾处开始遍历整个字符串，如果遇到非字母数字的字符就跳过，继续往下找，直到找到下一个字母数字或者结束遍历，如果遇到大写字母，就将其转为小写。等左右指针都找到字母数字时，比较这两个字符，若相等，则继续比较下面两个分别找到的字母数字，若不相等，直接返回false。

## 127

**题目描述**

给定一个单词字典，给定一个起始单词和一个结束单词，每次变换只能改变一个字母，并且中间过程的单词都必须是单词字典中的单词，求出最短的变化序列的长度。

**解题思路**

1. BFS
   - 使用 HashSet 保存所有的单词。
   - 把起始单词排入队列中，开始队列循环：取出队首词，然后对其每个位置上的字符，用 26 个字母进行替换，如果此时和结尾单词相同，返回当前遍历层数。如果替换词在字典中存在，将替换词排入队列中，并移除字典中的替换词；。如果循环完成则返回 0。

## 128

**题目描述**

最长连续序列长度，要求时间复杂度 O(n)。

**解题思路**

1. HashSet：存入所有的数字，然后遍历数组中的每个数字
   - 如果其在集合中存在，那么将其移除，这是为了避免大量的重复计算。
   - 然后分别用两个变量 pre 和 next 算出其前一个数跟后一个数，然后在集合中循环查找
   - 结束查找后，next-pre-1 就是当前数字的最长连续序列，更新res即可
2. HashMap：存储值到连续序列长度的映射
   - 遍历所有数字，如果该数字不在 HashMap 中，那么我们分别看其左右两个数字是否在 HashMap 中。
   - 如果在，则返回其哈希表中映射值，若不在，则返回 0。
   - 然后将 left+right+1 作为当前数字的映射，并更新 res 结果，同时更新 num-left 和 num-right 的映射值。

## 129

**题目描述**

每条从根节点到叶节点的路径都代表一个数字：比如路径 1 -> 2 -> 3 就表示数字 123。计算从根节点到叶节点生成的所有数字之和。

**解题思路**

1. DFS
2. 栈：首先将根结点压入栈，然后进行while循环，取出栈顶元素，如果是叶结点，那么将其值加入结果res。如果其右子结点存在，那么其结点值加上当前结点值的 10 倍，再将右子结点压入栈。同理，若左子结点存在，那么其结点值加上当前结点值的 10 倍，再将左子结点压入栈。

## 130

**题目描述**

二维棋盘上，将被包围的 'O' 都改为 'X'，注意的是边缘的 'O' 不算被包围。

**解题思路**

题目关键在于找到所有与边缘 'O' 接壤的 'O' 位置。

1. DFS: 维护一个 mask 数组，保存所有与边缘 'O' 接壤的 'O' 位置，最后把除了这些位置以外的更新为 'X' 即可。
2. DFS：不使用 mask 数组，直接改变原数组，将边缘的 'O' 及其相连接的 'O' 改为 '$'，这样剩下的 'O' 都是被包围的，然后将这些 'O' 变成 'X'，把 '$' 变回 'O' 就行。
3. BFS：在找到边界上的 'O' 后，然后利用队列 queue 进行 BFS 查找和其相连的所有 'O'，然后都标记上美元号。最后的处理还是先把所有的 'O'变成 'X'，然后再把美元号变回 'O' 即可。

## 131

**题目描述**

将一个字符串 s 分割成一些子串，使每个子串都是回文串，返回 s 所有可能的分割方案。

**解题思路**

1. DFS
   - 遍历所有的切割情况，首先判断取出的子串是否是回文串，调用一个判定回文串的子函数即可
   - 子函数传入了子串的起始和终止的范围，若子串是回文串，将其加入候选集，并且调用递归函数，此时 start 传入 i + 1，之后还要恢复 候选集 的状态。
2. DFS 进一步优化
   - 建立二维数组 dp，其中 dp[i][j] 表示 [i, j] 范围内的子串是否为回文串
   - 参见 <647. Palindromic Substrings> 的方法建立 dp 数组
3. 迭代
   - 三维数组 res，其中 res[i] 表示前 i 个字符组成的子串，即范围 [0, i+1] 内的子串的所有拆分方法
   - 进行 for 循环，i 从 0 到 n，j 从 0 到 i，对于区间 [j, i] 的子串，若其是回文串，则 dp[j][i] 更新为 true，并且遍历 res[j] 中的每一种组合，将当前子串加入，并且存入到 res[i+1]

## 132

**题目描述**

将字符串 s 分割成一些子串，使每个子串都是回文。返回符合要求的最少分割次数。

**解题思路**

1. 动态规划
   - judge[j][i] 表示 s.substr(j, j - i + 1) 是否为回文串
   - dp[i] 表示 s 的前 i 个字符的最小分割区域数目，dp[0] = 0
   - 计算回文子串时，当检测到 judge[j][i] 为回文串时，dp[i + 1] = min(dp[j] + 1, dp[i + 1])

## 133

**题目描述**

无向图的深拷贝

**解题思路**

1. 哈希+DFS：使用 HashMap 来对应原图中的结点和新生成的克隆图中的结点。
   - 在DFS递归函数中，首先判空，然后再看当前的结点是否已经被克隆过了
   - 若在 HashMap 中存在，则直接返回其映射结点，否则就克隆当前结点，并在 HashMap 中建立映射。
   - 然后遍历当前结点的所有 neighbor 结点，调用递归函数并且加到克隆结点的 neighbors 数组中即可。
2. 哈希+BFS：使用队列 queue 进行辅助
   - 先克隆当前结点，然后建立映射，并加入 queue 中，进行 while 循环。
   - 在循环中，取出队首结点，遍历其所有 neighbor 结点，若不在 HashMap 中，根据 neigbor 结点值克隆一个新 neighbor 结点，建立映射，并且排入 queue 中。
   - 然后将 neighbor 结点在 HashMap 中的映射结点加入到克隆结点的 neighbors 数组中即可

## 134

**题目描述**

一个环上有 N 个加油站，给定每个加油站的油量 gas[i]，车子从节点 i 驶向下一个节点 i+1 所要消耗的油量为 cost[i]。油箱为空的车子从某个节点出发，问是否能够绕环一圈回到原处。

**解题思路**

1. 基本定理：如果一个数组的总和非负，那么一定可以找到一个起始位置，从他开始绕数组一圈，累加和一直都是非负的
2. 题目可转化为求最大连续和。
3. $O(n)$ 做法：从位置 i 开始，i+1, i+2 ...，一路开过来一路油箱都没有空。说明从 i 到 i+1, i+2, ...一直是正积累。如果在位置 j 卡住走不下去，没必要从位置 i+1 重新走一遍，因为少了位置 i 的积累从 i+1 肯定走不到 j，所以可以直接从 j+1重新尝试，同时要把从 i 到 j 的负积累（debt）记录下来以便最后查看题目是否有解（详细看 1.定理）

## 135

**题目描述**

n 个孩子站在一排，每个孩子至少得到一个糖果，相邻孩子中得分高的孩子必须要有更多的糖果，求最少所需糖果数量

**解题思路**

1. 两次遍历：第一遍从左向右遍历，如果右边的小盆友的等级高，加一个糖果，这样保证了一个方向上高等级的糖果多。然后再从右向左遍历一遍，如果相邻两个左边的等级高，而左边的糖果又少的话，则左边糖果数为右边糖果数加一。

## 136

**题目描述**

非空数组，除了 X 只出现一次其他所有元素都出现了两次，找出 X。

**解题思路**

1. 位操作：两个相同的数取异或(^)结果为 0，所以对所有数取异或，结果即为 X

## 137

**题目描述**

非空数组，除了 X 只出现一次其他所有元素都出现了三次，找出 X。

**解题思路**

1. 位操作：建立一个 32 位的数字，来统计每一位上 1 出现的个数，如果该整数某一位出现了三次，对3取余为0，这样把每个数的对应位都加起来对3取余，最终剩下来的那个数就是单独的数字。

## 138

**题目描述**

链表（具有随机指针）的深拷贝

**解题思路**

1. 哈希+递归：建立一个 HashMap 来建立原链表结点和拷贝链表结点之间的映射。在递归函数中，首先判空，若为空，则返回空指针。然后去 HashMap 中查找是否已经在拷贝链表中存在了该结点，是的话直接返回。否则新建一个拷贝结点 res，然后建立原结点和该拷贝结点之间的映射，然后给拷贝结点的 next 和 random 指针赋值。
2. 迭代：不占用额外的空间
   1. 在原链表的每个节点后面拷贝出一个新的节点（新节点随机指针设为空）。e.g. 7(null)->13(0)->11(4)->10(2)->1(0) 变成  7(null)->7(null)->13(0)->13(null)->11(4)->11(null)->10(2)->10(null)->1(0)->1(null)
   2. 依次给新的节点的随机指针赋值 cur->next->random = cur->random->next
   3. 断开链表可得到深度拷贝后的新链表。

## 139

**题目描述**

给定单词和字典，判断单词能否被拆分成字典里面的内容。

**解题思路**

1. 动态规划
   - 判断“abcd”是否合法，可以通过判断 "a"&&"bcd" || "ab"&&"cd" || "abc"&&"d" || "abcd" 实现。
   - 用两个 for 循环来要遍历所有的子串，用 j 把 [0, i) 范围内的子串分为了两部分，[0, j) 和 [j, i)，其中范围 [0, j) 就是 dp[j]，范围 [j, i) 就是 s.substr(j, i-j)，其中 dp[j] 是之前的状态，只需要在字典中查找 s.substr(j, i-j) 是否存在，如果二者均为 true，将 dp[i] 赋为 true，并且跳出循环，此时就不需要再用j去分 [0, i) 范围了，因为 [0, i) 范围已经可以拆分。
2. 分治，方法同上。

## 140

**题目描述**

给定单词和字典，将单词拆分成字典里的单词，求出所有可以拆分的情况。

**解题思路**

1. 递归+记忆数组：
   - 使用一个 HashMap 保存 s 和其所有的拆分的字符串
   - 递归函数中，首先检测当前 s 是否已经有映射结果，有的话直接返回即可
   - 如果 s 为空了，放一个空字符串返回，单词之间是有空格，而最后一个单词后面没有空格，所以这个空字符串旧标记当前单词是最后一个，所以不需要再加空格
   - 遍历 wordDict 数组，如果某个单词是 s 字符串中的开头单词的话，对后面部分调用递归函数，将结果保存到 rem 中，然后遍历里面的所有字符串，和当前的单词拼接起来。for循环结束后，记得返回结果 res 之前建立其和 s 之间的映射，方便下次使用。

## 141

**题目描述**

检测链表是否存在环

**解题思路**

1. 双指针法：快指针每次走两格，慢指针每次走一格。如果快指针和慢指针相遇，则说明存在环。

## 142

**题目描述**

找到链表中的环的入口点

[[算法][LeetCode]Linked List Cycle & Linked List Cycle II——单链表中的环 - 南京大乱炖 - 博客园](https://www.cnblogs.com/hiddenfox/p/3408931.html)

**解题思路**

1. 快慢指针
   - 快慢指针相遇后，再让其中一个指针从链表头开始，再相遇的位置就是环的入口点
   - 快指针走的距离是慢指针的两倍。而快指针又比慢指针多走了一圈，所以ead 到环的起点+环的起点到相遇的点的距离 = 环的长度
   - 重新开始，head 运行到环起点 和 相遇点到环起点 的距离也是相等的

## 143

**题目描述**

重排链表，($L_{0} \rightarrow L_{n} \rightarrow L_{1} \rightarrow L_{n-1} \rightarrow L_{2} \rightarrow L_{n-2} \rightarrow \ldots$)

**解题思路**

1. 问题分解为三个子问题
   - (1) 使用快慢指针来找到链表的中点，并将链表从中点处断开，形成两个独立的链表。
   - (2) 将第二个链翻转。
   - (3) 将第二个链表的元素间隔地插入第一个链表中。
2. 可以借助栈的后进先出的特性反转链表，最后记得断开栈顶元素后面的结点。

## 144

**题目描述**

实现二叉树的前序遍历。

**解题思路**

1. 递归
2. 非递归+栈：把根节点 push 到栈中，然后循环检测栈是否为空，若不空，则取出栈顶元素，保存其值，然后看其右子节点是否存在，若存在则 push 到栈中。再看其左子节点，若存在，则 push 到栈中。
3. Morris 遍历

## 145

**题目描述**

实现二叉树的后序遍历。

**解题思路**

1. 递归
2. 迭代+栈+辅助节点
3. Morris 遍历

## 146

**题目描述**

实现一个 LRU 缓存器，要求 `get` 和 `put` 方法为 O(1) 时间复杂度。

**解题思路**

1. 双向链表+哈希表
   - 双向链表实现：dummy node，减少边界处理复杂度，并实现三个辅助函数
   - put 实现
     - 如果哈希表中中存在，移动至链表开头
     - 如果哈希表中不存在，新建节点并移动至链表开头，更新哈希表。
     - 如果新加入的节点导致超过了最大容量，更新哈希表，删除链表结尾节点。
   - get 实现
     - 如果哈希表中不存在，返回错误
     - 将命中的节点移动至链表开头，返回结果

## 147

**题目描述**

链表插入排序

**解题思路**

1. 迭代

## 148

**题目描述**

链表排序，要求 O(nlogn) 时间复杂度。

**解题思路**

1. 归并排序：通过快慢指针将链表从中间断开，分成两部分，左右两边再分别调用排序的递归函数 sortList()，得到各自有序的链表后，再进行 merge()。

## 150

**题目描述**

求解逆波兰表达式。逆波兰表达式就是把操作数放前面，把操作符后置的一种写法。

**解题思路**

1. 栈

## 151

**题目描述**

翻转字符串中的单词，如果单词间有多个空格只返回一个，且转换后的字符串首尾不能有空格。

**解题思路**

1. 可以认为单词是夹在边界或者空格中间，所以初始将 begin 设为-1（表示开始边界），之后每次遇到空格就更新 begin。同时遇到右边界或者有空格可以认为有单词结束，所以同时还需要加一个 word flag 指示是否当前遍历为单词。
2. 字符串流类 stringstream：先把字符串装载入字符串流中，然后定义一个临时变量tmp，然后把第一个单词赋给s
   - 如果含有非空格字符，那么每次 >> 操作就会提取连在一起的非空格字符，那么每次将其加在 s 前面即可；
   - 如果原字符串为空，那么就不会进入while循环；
   - 如果原字符串为许多空格字符连在一起，那么第一个 >> 操作就会提取出这些空格字符放入 s 中，然后不进入 while 循环，这时候我们只要判断一下 s 的首字符是否为空格字符，是的话就将 s 清空即可。
3. stringstream + getline：getline 第三个参数设定分隔字符为空格字符，每次只能过一个空格字符，如果有多个空格字符连在一起，那么 t 会赋值为空字符串，所以在处理 t 的时候首先要判断其是否为空，是的话直接跳过

**边界条件**

1. 字符串为空
2. 字符串（开始）末尾（没）有空格

## 152

**题目描述**

最大子乘积数组

**解题思路**

1. 动态规划
   - 设置两个 dp 数组
     - plus[i] 表示子数组 [0, i] 范围内并且一定包含 nums[i] 数字的最大子数组乘积
     - minus[i] 表示子数组 [0, i] 范围内并且一定包含 nums[i] 数字的最小子数组乘积
   - plus[i] 和 minus[i] 都初始化为 nums[0]
   - 从数组的第二个数字开始遍历，那么此时的最大值和最小值只会在这三个数字之间产生，即 $plus[i-1]*nums[i]$，$minus[i-1]*nums[i]$，和 $nums[i]$
   - 用三者中的最大值来更新 plus[i]，用最小值来更新 minus[i]
2. 进一步简化，先判断一个当前数字是否是负数，是的话就交换最大值和最小值
3. 正反遍历: 正向建立一个累加积数组，每次用出现的最大值更新结果 res，然后再反向建立一个累加积数组，再用出现的最大值更新结果 res

## 153

**题目描述**

找出旋转数组的最小值，数组中*无*重复值。

**解题思路**

1. 二分搜索
   - 用中间的值 nums[mid] 和右边界值 nums[right] 进行比较，若数组没有旋转或者旋转点在左半段的时候，中间值是一定小于右边界值的，所以要去左半边继续搜索，反之则去右半段查找，最终返回 nums[right] 即可
2. 分治：每次将区间 [start, end] 从中间 mid 位置分为两段，分别调用递归函数，并比较返回值，每次取返回值较小的那个即可

## 154

**题目描述**

找出旋转数组的最小值，数组中*有*重复值，如果有多个最小值返回坐标最小的。

**解题思路**

1. 二分搜索，参见 <153. Find Minimum in Rotated Sorted Array>
   - 将右指针左移一位（或者将左指针右移一位），略过一个相同数字
2. 分治：只有在 nums[start] < nums[end] 的时候，才能返回 nums[start]，等于的时候不能返回。

## 155

**题目描述**

实现最小栈：同时能够返回最小值的栈。

**解题思路**

1. 使用两个栈来实现，一个栈来按顺序存储 push 进来的数据，另一个用来存出现过的最小值。
2. 只使用一个栈：需要一个整型变量 min_val 来记录当前最小值，初始化为整型最大值
   - 如果需要进栈的数字小于等于当前最小值 min_val，则将 min_val 压入栈，并且将 min_val 更新为当前数字。
   - 在出栈操作时，先将栈顶元素移出栈，再判断该元素是否和 min_val 相等，相等的话将 min_val 更新为新栈顶元素，再将新栈顶元素移出栈即可

## 160

**题目描述**

Y 型交叉链表求入口节点

```txt
A:          a1 → a2
                      ↘
                        c1 → c2 → c3
                      ↗
B:     b1 → b2 → b3
```

**解题思路**

1. 链表拼接，A 的尾接 B 的头，B 的尾接 A 的头，从而相遇时候大家都走了 AB 的共同部分和 AB 的不同部分。这种方法如果存在不交叉怎么办？
2. 链表长度求差值: 分别遍历两个链表，得到分别对应的长度。然后求长度的差值，把较长的那个链表向后移动这个差值的个数，然后一一比较即可。

## 162

**题目描述**

寻找峰值(局部最大值)，峰值就是比周围两个数字都大的数字，如果有多个局部最大值随机返回其中一个即可，要求 O(logn) 复杂度。

**解题思路**

1. 二分搜索：折半后选择中间那个元素和紧跟的那个元素比较下大小，如果大于，则说明峰值在前面，如果小于则在后面。

## 164

**题目描述**

给一个乱序的数组，求出数组排序以后的相邻数字的差最大是多少。要求时间复杂度 O(n)。

**解题思路**

1. 桶排序
   - 首先找出数组的最大值和最小值以确定每个桶的容量，即为 len = (max - min) / n + 1
   - 区间分别为：`[min,min+len)`, `[min+len,min+2*len)`, `[min+2*len,min+3*len)`, ... `[max-len,max]`
   - 桶的个数为 (max - min) / len + 1
   - 最大间距的两个数不会在同一个桶中，而是一个桶的最小值和另一个桶的最大值

**边界条件**

1. 可能存在空桶

## 165

**题目描述**

比较两个版本号。

**解题思路**

1. 每次对应取出相同位置的小数点之前所有的字符，把他们转为数字比较，若不同则可直接得到答案，若相同，再对应往下取。如果一个数字已经没有小数点了，则默认取出为 0，和另一个比较。
2. 借助 stringstream 实现分段和转为整数。

**边界条件**

1. 无效 0，比如 01
2. 前导 0，比如 1.01 和 1.0001
3. 后导 0，比如 1.01.0.0.0

## 166

**题目描述**

给定被除数和除数，结果用小数表示，将循环部分用括号包裹起来。

**解题思路**

1. 组成部分：
   - 正负判断：被除数和除数取符号后相乘。
   - 整数部分：取绝对值后做除法即可。
   - 小数部分的循环部分：哈希表存每个小数位上的数字。每次把余数乘 10，再除以除数，得到的商即为小数的下一位数字。

**边界条件**

1. 对 INT_MIN 取绝对值就会超出范围

## 167

**题目描述**

已排序数组找两数之和

**解题思路**

1. 双指针

## 168

**题目描述**

excel 中数字到列标识的转换，即 1 对应 A，2 对应 B，27 对应 AA。

**解题思路**

1. 进制转换。

## 169

**题目描述**

找到数组中出现次数超过一半(⌊n / 2⌋)的元素，要求线性时间复杂度和 O(1) 空间复杂度。

**解题思路**

1. 多数投票算法(Boyer-Moore Algorithm)：扫描两次数组，第一趟记录 candidate (初值可以为任何数)和 count (初值为0)，之后，对于数组中每一个元素，首先判断 count 是否为0，若为0，则把 candidate 设置为当前元素。之后判断 candidate 是否与当前元素相等，若相等则count+=1，否则count-=1。第二趟扫描来统计 candidate 出现的次数来判断其是否为多数元素。该算法无法找到一个序列的众数，除非众数出现的次数大于 ⌊n/2⌋ 次
2. 位操作：检查每一个二进制位是否为1，如果是就累加 count， 如果count>n/2就置为1。

## 171

**题目描述**

excel 中列标识到数字的转换，即 A 对应 1，B 对应 2，AA 对应 27，本质是二十六进制转十进制的问题。

**解题思路**

1. 进制转化

## 172

**题目描述**

一个数的阶乘末尾 0 的个数。

**解题思路**

1. 其实就是找乘数中 10 的个数，而 10 可分解为 2 和 5，而 2 的数量又远大于 5 的数量，问题转化为找出 5 的个数。需要注意的是，像 25，125 这样的不只含有一个 5 的数字需要考虑进去。
2. 递归写法

## 173

**题目描述**

实现二叉搜索树 iterator，调用 `next()` 可以返回当前 iterator 的下一个元素。要求 O(1) 时间复杂度，O(h) 空间复杂度。

**解题思路**

1. 通过中序遍历将二叉树转化成排序好的数组。空间复杂度为 O(n)。
2. 栈 + 中序遍历

## 174

**题目描述**

恶魔抓住了公主并将她关在了地下城的右下角，地下城是由 M x N 个房间组成的二维网格。英勇的骑士最初被安置在左上角的房间里，他必须穿过地下城并通过对抗恶魔来拯救公主。骑士的初始健康点数为一个正整数。如果他的健康点数在某一时刻降至 0 或以下，他会立即死亡。有些房间由恶魔守卫，因此骑士在进入这些房间时会失去健康点数（若房间里的值为负整数，则表示骑士将损失健康点数）；其他房间要么是空的（房间里的值为 0），要么包含增加骑士健康点数的魔法球（若房间里的值为正整数，则表示骑士将增加健康点数）。为了尽快到达公主，骑士决定每次只向右或向下移动一步。计算确保骑士能够拯救到公主所需的最低初始健康点数。

**解题思路**

1. 动态规划
   - `dp[i][j]` 表示当前位置 (i, j) 出发的起始血量(即不考虑当前房间产生的影响)
   - 最先处理公主所在的房间的起始生命值，然后慢慢向第一个房间扩散，不断的得到各个位置的最优的生命值。
   - 状态转移方程 `dp[i][j] = max(1, min(dp[i+1][j], dp[i][j+1]) - dungeon[i][j])`。
   - 为了更好的处理边界情况，二维 dp 数组比原数组的行数列数均多 1 个，先都初始化为整型数最大值 INT_MAX，到达公主房间后，骑士火拼完的血量至少为1，那么此时公主房间的右边和下边房间里的数字都设置为 1。
2. 动态规划：使用一维数组

## 175

**题目描述**



**解题思路**



## 176

**题目描述**



**解题思路**



## 177

**题目描述**



**解题思路**



## 178

**题目描述**



**解题思路**



## 179

**题目描述**

给定一个数组，将其拼接成最大的数。

**解题思路**

1. 自定义排序
   - 9要排在最前面，而9既不是数组中最大的也不是最小的，所以要自定义排序方法。
   - 对于两个数字a和b来说，如果将其都转为字符串，如果 ab > ba，则a排在前面，比如9和34，由于 934>349，所以9排在前面，再比如说 30 和3，由于 303<330，所以3排在 30 的前面。
   - 按照这种规则对原数组进行排序后，将每个数字转化为字符串再连接起来就是最终结果。

## 180

**题目描述**



**解题思路**



## 181

**题目描述**



**解题思路**



## 182

**题目描述**



**解题思路**



## 183

**题目描述**



**解题思路**



## 184

**题目描述**



**解题思路**



## 185

**题目描述**



**解题思路**



## 187

**题目描述**

检测重复出现的 DNA 序列（10个字符为一个序列）

**解题思路**

1. 基本做法：hash，将连续的十个字符映射为唯一，出现重复时就加入到结果。同时，为了减少内存使用，可考虑位操作。用两位来表示一个字符，00 表示A，01 表示C，10 表示G，11 表示T，那么总共需要 20 位就可以表示十个字符流。

**边界条件**

1. 可能会出现多次重复（要去重）

## 188

**题目描述**

买进前必须卖出手头已有的；允许最多 k 次交易。

**解题思路**

1. 动态规划
   - 维护两个变量：全局最优 global 和局部最优 local。
   - 定义局部最优 `local[i][j]` 为在到达第 i 天时最多可进行 j 次交易并且最后一次交易在最后一天卖出的最大利润。
   - 定义全局最优 `global[i][j]`为在到达第 i 天时最多可进行 j 次交易的最大利润。
   - 递推式为 `local[i][j] = max(global[i - 1][j - 1] + max(diff, 0), local[i - 1][j] + diff)`，`global[i][j] = max(local[i][j], global[i - 1][j])`
   - 局部最优值是比较前一天并少交易一次的全局最优加上大于0的差值，和前一天的局部最优加上差值后相比，两者之中取较大值。前者是加上了 (i-1, i) 这笔交易，后者是修改最后一次交易的结束日为 i。
   - 而全局最优比较局部最优和前一天的全局最优。
   - 上面的算法中对于天数需要一次扫描，而每次要对交易次数进行递推式求解，所以时间复杂度是 O(n*k)，如果是最多进行两次交易，那么复杂度还是 O(n)。空间上只需要维护当天数据皆可以，所以是 O(k)，当k=2，则是 O(1)。
   - 为了减少运算次数，当 k 远大于天数时，按照 <122. Best Time to Buy and Sell Stock II> 中无限次数交易的方法求解。

## 189

**题目描述**

数组旋转，要求空间复杂度为 O(1)

**解题思路**

1. cur 初始化为数组第一个数字，idx 表示当前在交换的位置，start 表示最开始启动交换的位置，防止陷入死循环
   - 首先 pre 更新为 cur，然后计算新的 idx 的位置，然后将 nums[idx] 上的值先存到 cur 上，然后把 pre 赋值给 nums[idx]，这相当于把上一轮的 nums[idx] 赋给了新的一轮，完成了数字的交换，然后 if 语句判断是否会变到处理过的数字。
2. 先把前 n-k 个数字翻转一下，再把后 k 个数字翻转一下，最后再把整个数组翻转。
3. 不停交换某两个数字的位置来实现旋转。

## 190

**题目描述**

位反转

**解题思路**

## 191

**题目描述**

bit 1 的数量

**解题思路**

1. 通过 n & n - 1 将 n 的最右边的 1 置为 0
2. 逻辑右移 n。

## 192

**题目描述**



**解题思路**



## 193

**题目描述**



**解题思路**



## 194

**题目描述**



**解题思路**



## 195

**题目描述**



**解题思路**



## 196

**题目描述**



**解题思路**



## 197

**题目描述**



**解题思路**



## 198

**题目描述**

抢劫房屋，相邻的房屋连接了安全系统，如果相邻的房屋被闯入，安全系统会自动联系警察，求不在惊动警察的情况下最多能抢劫到的金钱。问题本质为，在一列数组中取出一个或多个不相邻数，使其和最大。

**解题思路**

1. 动态规划
   - 两个被打劫的家中间的间隔可能是1或2（不可能大于2）
   - 维护一个一维数组 dp，其中 dp[i] 表示 [0, i] 区间可以抢夺的最大值（并且 i 位置要抢）。
   - 状态转移方程为 $\text{dp}[i] = \text{max}(\text{dp}[i-2], \text{dp}[i-3]) + \text{nums}[i]$。
2. 动态规划
   - 维护一个一维数组 dp，其中 dp[i] 表示 [0, i] 区间可以抢夺的最大值（ i 位置不一定要抢）。
   - 状态转移方程为 $\text{dp}[i] = \text{max}(\text{dp}[i-2]+\text{nums}[i], \text{dp}[i-1])$。

## 199

**题目描述**

打印出二叉树每一行最右边的一个数字。

**解题思路**

1. 层序遍历: 遍历每层的节点时，把下一层的节点都存入到 queue 中，每当开始新一层节点的遍历之前，先把新一层最后一个节点值存到结果中
2. 前序遍历：利用变形前序访问来求得right view

## 200

**题目描述**

矩阵中连续区域的个数.

**解题思路**

1. DFS: 维护一个 visited 数组用来记录某个位置是否被访问过，对于一个为 ‘1’ 且未被访问过的位置，递归进入其上下左右位置上为 ‘1’ 的数，将其 visited 对应值赋为 true，继续进入其所有相连的邻位置，这样可以将这个连通区域所有的数找出来，并将其对应的 visited 中的值赋 true，找完相邻区域后，将结果 res 自增1，然后再继续找下一个为 ‘1’ 且未被访问过的位置。
2. BFS: 借助队列 queue 实现。

## 201

**题目描述**

给定范围 [m, n] 内所有数字进行与操作后的结果。

**解题思路**

1. 结果数是该数字范围内所有的数的左边共同的 '1' 部分

## 202

**题目描述**

对于某一个正整数，如果对其各个位上的数字分别平方，然后再加起来得到一个新的数字，再进行同样的操作，如果最终结果变成了1，则说明是快乐数。

**解题思路**

首先找规律，以 11 为例

```txt
1^2 + 1^2 = 2
2^2 = 4
4^2 = 16
1^2 + 6^2 = 37
3^2 + 7^2 = 58
5^2 + 8^2 = 89
8^2 + 9^2 = 145
1^2 + 4^2 + 5^2 = 42
4^2 + 2^2 = 20
2^2 + 0^2 = 4
```

发现数字 4 反复出现，说明计算过程中总会出现循环。

1. 用 HashSet 来记录所有出现过的数字，然后每出现一个新数字，在 HashSet 中查找看是否存在，若不存在则加入表中，若存在则跳出循环，并且判断此数是否为 1，若为 1 返回true，不为1返回false
2. 关于非快乐数有个特点，循环的数字中必定会有 4。
3. 快慢指针: 用于检测循环

## 203

**题目描述**

从链表中移除所有给定值的节点

**解题思路**

1. 迭代: 判断下一个结点的值跟给定值相同的话，直接跳过下一个结点，将 next 指向下下一个结点。最后还要验证头结点是否需要删除，要的话直接返回下一个结点
2. 递归: 通过递归调用到链表末尾，然后回来，碰到要删的元素，将链表next指针指向下一个元素即可。

## 204

**题目描述**

给定一个非负数 n，求小于 n 的质数的个数

**解题思路**

1. 埃拉托斯特尼筛法(Sieve of Eratosthenes)
   - [埃拉托斯特尼筛法 - 维基百科，自由的百科全书](https://zh.wikipedia.org/wiki/%E5%9F%83%E6%8B%89%E6%89%98%E6%96%AF%E7%89%B9%E5%B0%BC%E7%AD%9B%E6%B3%95)
   - 从 2 开始遍历到根号 n，先找到第一个质数 2，然后将其所有的倍数全部标记出来，然后到下一个质数3，标记其所有倍数，以此类推，直到根号 n，此时数组中未被标记的数字就是质数。

## 205

**题目描述**

同构字符串: 所有出现的字符都必须替换为另一个字符，同时保留字符的顺序。没有两个字符可以映射到同一个字符，但一个字符可以映射到它自己。

**解题思路**

1. HashMap
   - 用两个 HashMap 分别来记录原字符串和目标字符串中字符出现情况
   - 遍历原字符串，分别从源字符串和目标字符串取出一个字符，然后分别在两个数组中查找其值，若不相等，则返回 false，若相等，将其值更新为 i + 1

## 206

**题目描述**

反转链表

**解题思路**

1. 迭代
   - 在原链表之前建立一个空的 newHead
   - 然后从 head 开始，将之后的一个节点移到 newHead 之后，重复此操作直到 head 成为末节点为止
2. 递归

## 207

**题目描述**

每个课程都有先修课程，问是否会出现无法修完的情况

**解题思路**

1. 拓扑排序
   - 这个问题相当于查找有向图中是否存在环
   - 统计每个节点的入度，将入度为 0 的节点删掉，不断循环反复这个过程，如果最后还有节点入读不为 0，则说明存在环。
   - 拓扑排序可以用 BFS 解决，也可以通过 DFS 解决
2. 拓扑排序的 DFS 实现
   - 需要一个一维数组 visit 来记录访问状态，这里有三种状态，0表示还未访问过，1表示已经访问了，-1 表示有冲突。
   - 先建立好有向图，然后从第一个课开始，找其可构成哪门课，暂时将当前课程标记为已访问，然后对新得到的课程调用 DFS 递归，直到出现新的课程已经访问过了，则返回 false，没有冲突的话返回 true，然后把标记为已访问的课程改为未访问。

## 208

**题目描述**

实现前缀树(字典树)，字典树主要有如下三点性质：

1. 根节点不包含字符，除根节点以外每个节点只包含一个字符。
2. 从根节点到某一个节点，路径上经过的字符连接起来，为该节点对应的字符串。
3. 每个节点的所有子节点包含的字符串不相同。

![208 Prefix Tree](https://gitlab.com/convexwf/convex-resource/-/raw/master/convex-notes/leetcode-208_Prefix_Tree.png)

**解题思路**

前缀树的插入（Insert）、删除（ Delete）和查找（Find）都非常简单，第 i 次循环找到前 i 个字母所对应的子树，然后进行相应的操作。实现上，使用最常见的数组保存（静态开辟内存）即可，当然也可以开动态的指针类型（动态开辟内存）。至于结点对儿子的指向，一般有三种方法：

1、对每个结点开一个字母集大小的数组，对应的下标是儿子所表示的字母，内容则是这个儿子对应在大数组上的位置，即标号；
2、对每个结点挂一个链表，按一定顺序记录每个儿子是谁；
3、使用左儿子右兄弟表示法记录这棵树。

第一种易实现，但实际的空间要求较大；第二种，较易实现，空间要求相对较小，但比较费时；第三种，空间要求最小，但相对费时且不易写。以下给出第一种实现方法。

**边界条件**

1. 先插入 apple, 再插入 app，所以需要对每一个节点设置 is_word 标志位，不能简单通过是不是叶子节点来判断。

## 209

**题目描述**

求子数组之和大于等于给定值的最小长度。

**解题思路**

1. 滑动窗口：用两个指针分别子数组的左右的边界位置，然后让 right 向右移，直到子数组和大于等于给定值，此时将 left 向右移一位，然后在 sum 中减去移去的值，然后重复上面的步骤。O(n) 时间复杂度。
2. 二分搜索：建立一个比原数组长一位的 sums 数组，其中 sums[i] 表示 nums 数组中 [0, i - 1] 的和，然后对于 sums 中每一个值 sums[i]，用二分查找法找到子数组的右边界位置，使该子数组之和大于 sums[i] + s，然后更新最短长度的距离即可。O(nlgn) 时间复杂度。

**边界条件**

1. 数组不存在大于等于指定值的子序列

**Follow up**

1. 去掉所有数字是正数的限制条件

## 210

**题目描述**

每个课程都有先修课程，求修课程的顺序，如果有多种可能只返回一种即可。

**解题思路**

1. 拓扑排序
   - 从 queue 中每取出一个数组就将其存在结果中，最终若有向图中有环，则结果中元素的个数不等于总课程数，将结果清空即可。

## 211

**题目描述**

设计一种数据结构支持以下两种操作：`addWord(word)` 添加单词，`search(word)` 搜索单词，并支持通配符 `.`(匹配任意单个字符)。

**解题思路**

1. 利用前缀树实现即可。

## 212

**题目描述**

给定一个二维网格 board 和一个字典中的单词列表words，找出所有同时在二维网格和字典中出现的单词。

**解题思路**

1. 前缀树 + DFS

TODO

<https://leetcode.com/problems/word-search-ii/discuss/59780/Java-15ms-Easiest-Solution-(100.00>

## 213

**题目描述**

<198. House Robber> 的扩展，房子围成了一个圆圈，不能够同时抢首尾的房屋

**解题思路**

1. 动态规划
   - 房子围成环后，可以发现第一家和最后一家不能同时抢，恰好分解为两个子问题：分别计算去掉第一家和最后一家后能抢到的最大值，对两个极大值取最大即为所求。
2. 使用两个变量 rob 和 notRob，其中 rob 表示抢当前的房子，notRob 表示不抢当前的房子，那么在遍历的过程中，先用两个变量 preRob 和 preNotRob 来分别记录更新之前的值，由于 rob 是要抢当前的房子，那么前一个房子一定不能抢，所以使用 preNotRob 加上当前的数字赋给 rob，然后 notRob 表示不能抢当前的房子，那么之前的房子就可以抢也可以不抢，所以将 preRob 和 preNotRob 中的较大值赋给 notRob

## 214

**题目描述**

在给定字符串 s 的前面加上尽可能少的字符，使之变成回文串。

**解题思路**

1. KMP 算法：把 s 和其转置 r 连接起来，中间加上一个其他字符，形成一个新的字符串 t，还需要一个和 t 长度相同的一位数组 next，其中 next[i] 表示从 t[i] 到开头的子串的相同前缀后缀的个数。最后把不相同的个数对应的字符串添加到 s 之前即可。

## 215

**题目描述**

求数组中第 k 大的数字。

**解题思路**

1. 小顶堆
2. 快速排序：先找一个中枢点 Pivot，然后遍历其他所有的数字，把大于中枢点的数字放到左半边，把小于中枢点的放在右半边，这样中枢点是整个数组中第几大的数字就确定了，虽然左右两部分各自不一定是完全有序的。如果位置正好是 k-1，那么直接返回该位置上的数字；如果大于 k-1，说明要求的数字在左半部分，更新右边界，再求新的中枢点位置；反之则更新右半部分，求中枢点的位置。

## 216

**题目描述**

找出所有相加之和为 n 的 k 个数的组合。组合中只允许含有 1 - 9 的正整数，并且每种组合中不存在重复的数字。

**解题思路**

1. 递归：n 是 k 个数字之和，如果 n 小于 0，则直接返回，如果 n 正好等于 0，而且此时 out 中数字的个数正好为 k，说明此时是一个正确解，将其存入结果 res 中。

## 217

**题目描述**

数组中是否有重复数字

**解题思路**

1. hashset: 遍历整个数组，如果哈希表里存在，返回false，如果不存在，则将其放入哈希表中

## 219

**题目描述**

对于数组(array)，判断是否出现重复值，且重复值之间下标距离不大于 k

**解题思路**

1. HashMap
   - 存储值到下标的映射。
   - 从左到右遍历数组，如果当前值的当前下标距离当前值的前下标不大于 k, 则认为出现重复。

## 220

**题目描述**

两个数字的坐标差不能大于 k，值差不能大于 t

**解题思路**

1. 双指针 + map
   - 两个指针 i 和 j 刚开始都指向0，然后 i 开始向右走遍历数组，如果 i 和 j 之差大于 k，且 m 中有 nums[j]，则删除并 j 加一，这样保证了 m 中所有的数的下标之差都不大于 k。
   - 使用 lower_bound() 函数来查找大于或等于 nums[i] - t 的位置，然后检测后面的所有的数字，如果两数的差的绝对值小于等于 t，则返回true。
   - 最后遍历完整个数组返回 false。

## 221

**题目描述**

在一个由 '0' 和 '1' 组成的二维矩阵内，找到只包含 '1' 的最大正方形，并返回其面积。

**解题思路**

1. brute force
   - 把数组中每一个点都当成正方形的左顶点来向右下方扫描，来寻找最大正方形。
   - 确定了左顶点后，再往下扫的时候，正方形的竖边长度就确定了，只需要找到横边即可，这时候使用直方图的原理，从其累加值能反映出上面的值是否全为 1。
2. 累计和数组
   - 建立好了累加和数组后，开始遍历二维数组的每一个位置，对于任意一个位置 (i, j)，从该位置往 (0,0) 点遍历所有的正方形，正方形的个数为 `min(i, j) + 1`，由于累加和矩阵能快速的求出任意一个区域之和，所以能快速得到所有子正方形之和，比较正方形之和跟边长的平方是否相等，相等说明正方形中的数字均为1，更新 res 结果即可。
3. 动态规划：`dp[i][j]` 表示到达 (i, j) 位置所能组成的最大正方形的边长。
   - 当 i 或 j 为 0 时，最多能组成长度为 1 的正方形，条件是当前位置为1。
   - 对于任意一点 `dp[i][j]`，只有当前 (i, j) 位置为 1，`dp[i][j]` 才有可能大于 0。
   - 当 (i, j) 位置为 1，`dp[i][j] = min(dp[i-1][j-1], dp[i][j-1], dp[i-1][j]) + 1`
4. 动态规划：一维数组处理

## 222

**题目描述**

完全二叉树节点的个数。

[二叉树 - 维基百科，自由的百科全书](https://zh.wikipedia.org/wiki/%E4%BA%8C%E5%8F%89%E6%A0%91)

完全二叉树 (Complete Binary Tree)：对于一颗二叉树，假设其深度为 d(d>1)。除了第 d 层外，其它各层的节点数目均已达最大值，且第 d 层所有节点从左向右连续地紧密排列，这样的二叉树被称为完全二叉树。

完美二叉树 (Perfect Binary Tree)：

1. 完美二叉树的第 \(i\) 层拥有 $2^{i-1}$ 个节点数；深度为 \(k\) 的完美二叉树总共有 $2^{k+1}-1$ 个节点数。
2. 完美二叉树一定是完全二叉树，而完全二叉树不一定是完美二叉树。

完满二叉树 (Full Binary Tree)：所有非叶子结点的度都是2。

**解题思路**

1. brute force: 递归统计结点的个数
2. 利用完美二叉树的性质：
   - 由 root 根结点往下，分别找最靠左边和最靠右边的路径长度
   - 如果长度相等，则证明二叉树最后一层节点是满的，是满二叉树，直接返回节点个数(2的h次方减1)
   - 如果不相等，则节点个数为左子树的节点个数加上右子树的节点个数再加1(根节点)
3. 二分查找(疑似)
   - getHeight 函数用鱼统计当前结点的左子树的最大高度的，若当前结点不存在，返回 -1。
   - 对当前结点调用 getHeight 函数，得到左子树的最大高度 h，若为 -1，则说明当前结点不存在，直接返回 0。
   - 否则就对右子结点调用 getHeight 函数，若返回值为 h-1，说明左子树是一棵完美二叉树，则左子树的结点个数是 $2^h-1$ 个，再加上当前结点，总共是 $2^h$ 个，此时再加上对右子结点调用递归函数的返回值即可。
   - 若对右子结点调用 getHeight 函数的返回值不为 h-1，说明右子树一定是完美树，且高度为 h-1，则总结点个数为 $2^(h-1)-1$，加上当前结点为 $2^(h-1)$，然后再加上对左子结点调用递归函数的返回值即可。

## 223

**题目描述**

二维坐标系中给出两个矩形四个点的坐标，求两个矩形覆盖的总面积。

![223 Rectangle Area 矩形坐标](https://gitlab.com/convexwf/convex-resource/-/raw/master/convex-notes/leetcode-223_Rectangle_Area_矩形坐标.png)

**解题思路**

1. 先找出所有的不相交的情况，只有四种，一个矩形在另一个的上下左右四个位置不重叠，这四种情况下返回两个矩形面积之和。其他情况下需要计算出交集面积。

## 224

**题目描述**

算术表达式计算，表达式中只有加减号，数字，括号和空格，没有乘除。

**解题思路**

1. 栈
   - 用变量 sign 来表示当前的符号
   - 遍历给定的字符串 s，如果遇到了数字，使用了一个变量来保存读入的 num；
   - 如果遇到了加号，则 sign 赋为1，如果遇到了符号，则赋为-1；
   - 如果遇到了左括号，则把当前结果 res 和符号 sign 压入栈，res 重置为 0，sign 重置为 1；
   - 如果遇到了右括号，结果 res 乘以栈顶的符号，栈顶元素出栈，结果 res 加上栈顶的数字，栈顶元素出栈。
2. 递归
   - 用一个变量 cnt，遇到左括号自增 1，遇到右括号自减 1，当 cnt 为0的时候，说明括号正好完全匹配
   - 根据左右括号的位置提取出中间的子字符串调用递归函数，返回值赋给 num

## 225

**题目描述**

用队列实现栈

**解题思路**

1. 每次把新加入的数插到队列前头，即在队尾加入了新元素x后，将x前面所有的元素都按顺序取出并加到队列到末尾，这样队列保存的顺序和栈的顺序是相反的，它们的取出方式也是反的。这种方法适用于写少读多的场景。
2. 两个队列，其中一个队列用来放最后加进来的数，模拟栈顶元素，剩下所有的数都按顺序放入另一个队列中。
   - 当 push() 操作时，将新数字先加入模拟栈顶元素的队列中，如果此时队列中有数字，则将原本有的数字放入另一个队中，让新数字在这队中，用来模拟栈顶元素。
   - 当 top() 操作时，如果模拟栈顶的队中有数字则直接返回，如果没有则到另一个队列中通过平移数字取出最后一个数字加入模拟栈顶的队列中。
   - 当 pop() 操作时，先执行下 top() 操作，保证模拟栈顶的队列中有数字，然后再将该数字移除即可。
   - 当 empty() 操作时，当两个队列都为空时，栈为空。
   - 这种方法适用于写多读少的场景。
3. 用一个数字存储栈顶，这样只需要在 pop 时候将全部数字弹出后重新入队列，适用于删除少的场景。

## 226

**题目描述**

翻转二叉树

**解题思路**

1. 递归
2. 迭代

## 227

**题目描述**

算术表达式计算，表达式中有加减乘除号，数字和空格，没有括号。

**解题思路**

1. 栈
   - 使用一个栈保存数字，如果该数字之前的符号是加或减，那么把当前数字压入栈中，注意如果是减号，则加入当前数字的相反数，因为减法相当于加上一个相反数。
   - 如果之前的符号是乘或除，那么从栈顶取出一个数字和当前数字进行乘或除的运算，再把结果压入栈中，那么完成一遍遍历后，所有的乘或除都运算完了，再把栈中所有的数字都加起来就是最终结果
2. num 表示当前的数字，curRes 表示当前的结果，res 为最终的结果，op 为操作符号，初始化为 '+'。根据 op 的值对 num 进行分别的加减乘除的处理，结果保存到 curRes 中。然后再次判断如果 op 是加或减，或者是最后一个位置的字符时，将 curRes 加到结果 res 中，并且 curRes 重置为 0。最后将当前字符 c 赋值给 op（注意这里只有当时最后一个位置的字符时，才有可能不是运算符号，不过也不要紧了，因为遍历已经结束了），num 也要重置为 0。

## 228

**题目描述**

总结有序数组的区间

**解题思路**

1. 每次检查下一个数是不是递增的，如果是，则继续往下遍历，如果不是，还要判断此时是一个数还是一个序列，一个数直接存入结果，序列的话要存入首尾数字和箭头“->"。

**边界条件**

1. $b - a <= 1$ 应写成 $a - 1 >= b$，防止溢出

## 229

**题目描述**

求出现次数大于 n/3 的数字，而且限定空间复杂度为 O(1)。

**解题思路**

任意一个数组出现次数大于 n/3 的数最多有两个。

证明：如果有超过两个，也就是至少三个数字满足“出现的次数大于 n/3”，那么就意味着数组里总共有超过 3*(n/3) = n 个数字，这与已知的数组大小矛盾

1. 多数投票法：找出两个候选数进行投票，需要两遍遍历，第一遍历找出两个候选数，第二遍遍历重新投票验证这两个候选数是否符合题意

## 230

**题目描述**

二叉搜索树中第 K 最小值。

**解题思路**

1. 中序遍历
2. 分治法
   - 利用 BST 的性质可以快速定位出第 k 小的元素是在左子树还是右子树。
   - 首先计算出左子树的结点个数总和 cnt，如果 k 小于等于左子树结点总和 cnt，说明第 k 小的元素在左子树中，直接对左子结点调用递归即可。如果 k 大于 cnt+1，说明目标值在右子树中，对右子结点调用递归函数。

**Follow up**

1. BST 被修改得很频繁，而且查找第 k 小元素的操作也很频繁。
   - 修改原树结点的结构，使其保存包括当前结点和其左右子树所有结点的个数，这样就可以快速得到任何左子树结点总数。

## 231

**题目描述**

判断一个数是否为 2 的次方，要求时间和空间复杂度都为常数

**解题思路**

1. 如果一个数是2的次方数的话，那么它的二进数必然是最高位为1，其它都为0，那么如果此时减1，最高位会降一位，其余为0的位现在都为变为1，此时把两数相与，就会得到0

## 232

**题目描述**

用栈实现队列

**解题思路**

1. 使用了两个栈_new和_old，其中新进栈的都先缓存在_new中，入股要pop和peek的时候，才将_new中所有元素移到_old中操作。

## 233

**题目描述**

统计比给定数小的所有数中 1 出现的个数。

**解题思路**

解题思路

1. 分类讨论
   - 10 以内的数字：看个位数是否大于 1，是就加上 1
   - 100 以内的数字：除了 10-19 之间有 11 个 '1' 之外，其余都只有 1 个。如果不考虑 [10, 19] 区间上那多出来的 10 个 '1'，对任意一个两位数，十位数上的数字(加1)就代表 1 出现的个数，这时候再把多出的 10 个加上即可。比如 56 就有 (5+1)+10=16 个。如何知道是否要加上多出的 10 个，就要看十位上的数字是否大于等于 2，是的话就要加上多余的 10 个 '1'。可以用 (x+8)/10 来判断一个数是否大于等于 2。
   - 1000 以内的数字：除了 [110, 119] 之间多出的10个数之外，共 21 个 '1'，其余的每 10 个数的区间都只有 11 个 '1'，所以 [100, 199] 内共有 21 + 11 * 9 = 120 个 '1'。[0, 999] 区间内 '1' 的个数怎么求？根据前面的结果，[0, 99] 内共有 20 个，[100, 199] 内共有 120 个，而其他每 100 个数内 '1' 的个数也应该符合之前的规律，即也是 20 个，那么总共就有 120 + 20 * 9 = 300 个 '1'。那么还是可以用相同的方法来判断并累加 1 的个数。

## 234

**题目描述**

检测回文链表，要求 O(n) 时间复杂度，O(1) 空间复杂度。

**解题思路**

1. 栈：利用栈的后入先出的特性，O(n) 时间复杂度，O(n) 空间复杂度。
2. 递归：在递归函数传入头节点。注意要在递归返回时才处理值比较，所以需要传入需要比较的指针作为引用。
3. 快慢指针+递归：首先通过快慢指针找到中间指针，然后通过递归比较值。
4. 快慢指针+迭代：找到中点后，将后半段的链表翻转。O(n) 时间复杂度，O(1) 空间复杂度。

## 235

**题目描述**

公共祖先节点: 二叉搜索树

**解题思路**

1. 利用 BST 的特性
   - 二叉搜索树的特点是左<根<右，所以根节点的值一直都是中间值，大于左子树的所有节点值，小于右子树的所有节点值，
   - 如果根节点的值大于p和q之间的较大值，说明p和q都在左子树中
   - 如果根节点小于p和q之间的较小值，说明p和q都在右子树中
   - 如果都不是，则说明当前根节点就是最小共同父节点，直接返回即可
2. 方法 1 的非递归写法

## 236

**题目描述**

公共祖先节点: 普通二叉树

**解题思路**

1. 如果当前结点不等于p或q，p和q要么分别位于左右子树中，要么同时位于左子树，或者同时位于右子树
   - 若p和q分别位于左右子树中，那么对左右子结点调用递归函数，会分别返回p和q结点的位置，而当前结点正好就是p和q的最小共同父结点，直接返回当前结点即可
   - 若p和q同时位于左子树，这里有两种情况，一种情况是 left 会返回p和q中较高的那个位置，而 right 会返回空，所以最终返回非空的 left 即可; 还有一种情况是会返回p和q的最小父结点，就是说当前结点的左子树中的某个结点才是p和q的最小父结点，会被返回。
   - 若p和q同时位于右子树，同样这里有两种情况，一种情况是 right 会返回p和q中较高的那个位置，而 left 会返回空，所以最终返回非空的 right 即可，还有一种情况是会返回p和q的最小父结点，就是说当前结点的右子树中的某个结点才是p和q的最小父结点，会被返回

**边界条件**

1. p和q不是树中的节点

## 237

**题目描述**

删除链表的一个节点，不提供链表的起点，只提供当前节点

**解题思路**

1. 先把当前节点的值用下一个节点的值覆盖，然后删除下一个节点即可

## 238

**题目描述**

给定一个数组，返回一个新数组，对于每一个位置上的数是其他位置上数的乘积，并且限定了时间复杂度 O(n)，并且不能用除法。

**解题思路**

1. 分别从数组的两个方向遍历就可以分别创建出乘积累积数组。
   - 为了进行空间上的优化，由于最终的结果都是要乘到结果 res 中，所以可以不用单独的数组来保存乘积，而是直接累积到结果 res 中。
   - 先从前面遍历一遍，将乘积的累积存入结果 res 中，然后从后面开始遍历，用到一个临时变量 right，初始化为1，然后每次不断累积，最终得到正确结果。

## 239

**题目描述**

给定一个数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。返回滑动窗口中的最大值。

**解题思路**

1. multiset: multiset是一种基于红黑树的数据结构，可以自动对元素进行排序，允许有重复值。
   - 首先遍历每个数字，即窗口右移，若超过了 k，则需要把左边界值删除，这里不能直接删除 nums[i-k]，因为集合中可能有重复数字，而 erase 默认是将所有和目标值相同的元素都删掉，所以只能提供一个 iterator 代表一个确定的删除位置，先通过 find() 函数找到左边界 nums[i-k] 在集合中的位置再删除。
   - 然后将当前数字插入到集合中，此时看若 i >= k-1，说明窗口大小正好是 k，就需要将最大值加入结果 res 中，而由于 multiset 是按升序排列的，最大值在最后一个元素，可以通过 rbegin() 来取出。
2. 优先队列/最大堆
   - 堆元素为由数字和其所在位置组成的 pair。
   - 在遍历每个数字时，进行 while 循环，假如优先队列中最大的数字此时不在窗口中了，就要移除，判断方法就是将队首元素的 pair 对儿中的 second（位置坐标）跟 i-k 对比，小于等于就移除。然后将当前数字和其位置组成 pair 对儿加入优先队列中。此时看若 i >= k-1，说明窗口大小正好是k，就将最大值加入结果 res 中即可。
3. deque
   - 用双向队列保存数字的下标，遍历整个数组，如果此时队列的首元素是 i-k，表示此时窗口向右移了一步，则移除队首元素。
   - 然后比较队尾元素和将要进来的值，如果小的话就都移除，这样可以确保队列中为近似降序排列。

## 240

**题目描述**

搜索 m x n 矩阵 matrix 中的一个目标值 target。该矩阵具有以下特性：每行的元素从左到右升序排列，每列的元素从上到下升序排列。

**解题思路**

1. i 指向 0，j 指向列数，这样第一个被验证的数就是二维数组右上角的数字，假如这个数字等于 target，直接返回 true；若大于 target，说明要减小数字，则列数 j 自减 1；若小于 target，说明要增加数字，行数 i 自增 1。

## 241

**题目描述**

给了一个可能含有加减乘的表达式，在任意位置添加括号，求出所有可能表达式的不同值。

**解题思路**

1. 分治法
   - 先建立一个结果 res 数组，然后遍历 input 中的字符，在每个运算符的地方，将 input 分成左右两部分，从而扔到递归中去计算，从而可以得到两个整型数组 left 和 right，分别表示作用两部分各自添加不同的括号所能得到的所有不同的值，再分别从两个数组中取数字进行当前的运算符计算，然后把结果存到 res 中即可。当然，若最终结果 res 中还是空的，那么只有一种情况，input 本身就是一个数字，直接转为整型存入结果 res 中即可
2. 分治法+HashMap：使用 HashMap 来保存已经计算过的情况，这样可以减少重复计算，从而提升运算速度，以空间换时间
3. 动态规划
   - 三维 dp，其中 `dp[i][j]` 表示在第i个数字到第j个数字之间范围内的子串添加不同括号所能得到的不同值的整型数组
   - 对 input 字符串进行预处理，将数字跟操作分开，加到一个字符串数组 ops 中，并统计数字的个数 cnt，用这个 cnt 来初始化 dp 数组的大小，并同时要把 `dp[i][j]` 的数组中都加上第 i 个数字，通过 `ops[i*2]` 取得，当然还需要转为整型数。
   - 更新顺序是从小区间往大区间更新

## 242

**题目描述**

两个词是否互为变位词(组成字母一样)

**解题思路**

1. 先判断两个字符串长度是否相同，不相同直接返回 false。然后把 s 中所有的字符出现个数统计起来，存入一个大小为 26 的数组中，因为题目中限定了输入字符串为小写字母组成。然后再来统计 t 字符串，如果发现不匹配则返回 false。

## 257

**题目描述**

返回二叉树所有根到叶节点的路径

**解题思路**

1. DFS：当遇到叶结点的时候，此时一条完整的路径已经形成了，加上当前的叶结点后存入结果 res 中。
2. DFS：在一个函数内完成。

## 260

**题目描述**

非空数组，其中只有两个元素只出现过一次，其余元素都出现了两次。找到只出现了一次的两个元素。要求 O(n) 时间复杂度，O(1) 空间复杂度。

**解题思路**

1. 位操作
   - 把原数组逐一做异或操作，会得到一个数字，这个数字是两个结果数字异或的结果。
   - 用 `a & -a` 取出 a 最右边的 1，该位置为两个结果数字不同的位，从而区分出两个不同的数字。

## 263

**题目描述**

检测一个数是否为丑数，丑数只含有质因数 (2, 3, 5)

**解题思路**

1. 只要对某数不断除以 (2, 3, 5) 直到剩余数字为 1 即可判断为丑数

边界条件

1. 1 也是丑数

## 264

**题目描述**

找到第 n 个丑数，丑数只含有质因数 (2, 3, 5)

**解题思路**

1. 新的丑数可以认为是从已有的丑数序列生成的。为 (2, 3, 5) 都各自分配一个下标指向丑数序列，其实就可以当做是三个已经生成的序列，每次都从这三个列表中取出当前最小的那个作为新丑数，当有新的丑数加入就把产生效果的下标加1。
2. 和方法 1 类似，使用最小堆来做，首先放进去一个 1，然后循环 n 次，每次取出堆顶元素，为了确保没有重复数字，进行一次 while 循环，将此时和堆顶元素相同的都取出来，然后分别将这个取出的数字乘以 2，3，5，并分别加入最小堆。

## 268

**题目描述**

给定 [0, n] 范围内互不相同的 n 个数字，找出缺失的数字。

**解题思路**

1. 利用等差数列的特性，计算出 0\~n 的序列和，然后再遍历数组算出给定数字的累积和，然后做减法，差值就是丢失的那个数字。
2. 位操作: 将这个少了一个数的数组同 0 到 n 之间完整的数组进行异或操作，相同的数字都变为0，剩下的就是少了的那个数字。
3. 二分查找: 如果数组有序，可将时间复杂度降为 O(logn)。如果元素值大于下标值，则说明缺失的数字在左边，此时将 right 赋为 mid，反之则将 left 赋为 mid+1。

## 273

**题目描述**

整型数转为用英文单词描述

**解题思路**

1. 枚举
   - 每 3 个 1 组进行处理
   - 输入数字范围为 0 到 2^31 - 1 之间，最高只能到 billion 位
   - 一个三位数 n，百位数表示为 n / 100，后两位数一起表示为 n % 100，十位数表示为 n % 100 / 10，个位数表示为 n % 10
   - 单词数组：需要把 1 到 19 的英文单词都列出来，还要把 20,30，... 到 90 的英文单词列出来放到另一个数组里

**边界条件**

1. 0，返回 Zero

## 274

**题目描述**

求 H 指数，该指数用来衡量研究人员的学术水平的质数，定义为一个人的学术文章有 n 篇分别被引用了 n 次，那么 H 指数就是 n。

可以按照如下方法确定某人的 H 指数：1、将其发表的所有SCI论文按被引次数从高到低排序；2、从前往后查找排序后的列表，直到某篇论文的序号大于该论文被引次数。所得序号减一即为 H 指数。

**解题思路**

1. 降序排序
2. 计数排序：定义 n+1 个桶(0 \~ n)，引用次数大于等于 n 的放入序号为 n 的桶。然后从大到小遍历桶，累加计数，当累计值大于等于当前桶序号时，返回当前桶序号。

## 275

**题目描述**

求 H 指数，输入数组是有序的，要求 O(log n) 时间复杂度。

**解题思路**

1. 二分查找：问题转化为查找第一个 `citations[i] > n - 1 - i` 的元素。

## 278

**题目描述**

在一系列版本中找出第一个坏版本，坏版本后都是坏版本，给了一个 API 函数可以用来判定当前版本是否是坏的，尽可能少调用这个 API。

**解题思路**

1. 二分查找

## 283

**题目描述**

将数组中所有的 0 都移到后面，把非零数前移，要求不能改变非零数的相对位置关系，要求 in-place。

**解题思路**

1. partition，用两个指针，一个不停的向后扫，找到非零位置，然后和前面那个指针交换位置即可。

## 284

**题目描述**

给迭代器增加一个 peek 方法，查看下一个元素，且不能移动迭代器指针。

**解题思路**

1. 局部变量：创建一个副本，然后让副本移动到下一个，并返回，由于是局部变量，副本在调用结束后也会被销毁
2. cache：定义一个变量专门来保存下一个值，再用一个bool型变量标记是否保存了下一个值。

## 287

**题目描述**

给定一个包含 n + 1 个整数的数组，其中每一个整数均介于 [1, n] 之间，其中至少有一个重复元素存在（鸽巢原理）。假设只有一个数字出现重复，找出这个重复的数字。要求不能改动原数组（排序），O(1) extra space，less than O(n2) runtime complexity。

**解题思路**

1. 位操作：遍历每一位，然后对于 32 位中的每一个位 bit，都遍历一遍从 0 到 n-1，将 0 到 n-1 中的每一个数都跟 bit 相与，若大于0，则计数器 cnt1 自增1。同时 0 到 n-1 也可以当作 nums 数组的下标，从而让 nums 数组中的每个数字也跟 bit 相与，若大于0，则计数器 cnt2 自增1。最后比较若 cnt2 大于 cnt1，则将 bit 加入结果 res 中。因为对于每一位，0 到 n-1 中所有数字中该位上的 1 的个数应该是固定的，如果 nums 数组中所有数字中该位上 1 的个数多了，说明重复数字在该位上一定是 1，这样我们把重复数字的所有为 1 的位都累加起来，就可以还原出这个重复数字。
2. 快慢指针：限定了区间 [1,n]，所以可以利用坐标和数值之间相互转换，而由于重复数字的存在，那么一定会形成环，用快慢指针可以找到环并确定环的起始位置。

## 289

**题目描述**

细胞自动机，每一个位置有两种状态，1为活细胞，0为死细胞，对于每个位置都满足如下的条件：

1. 如果活细胞周围八个位置的活细胞数少于两个，则该位置活细胞死亡
2. 如果活细胞周围八个位置有两个或三个活细胞，则该位置活细胞仍然存活
3. 如果活细胞周围八个位置有超过三个活细胞，则该位置活细胞死亡
4. 如果死细胞周围正好有三个活细胞，则该位置死细胞复活

计算出细胞自动机的下一个状态，要求 in-place 空间复杂度，要求同时更新所有细胞的状态。

**解题思路**

1. 可以通过状态机转换同时知道其未更新和已更新的状态。最后对所有状态对2取余，则状态0和2就变成死细胞，状态1和3就是活细胞
   - 状态0： 死细胞转为死细胞
   - 状态1： 活细胞转为活细胞
   - 状态2： 活细胞转为死细胞
   - 状态3： 死细胞转为活细胞

## 290

**题目描述**

给定模式字符串和单词字符串，判断单词字符串中单词出现的规律是否符合模式字符串中的规律。模式中的字符唯一对应一个单词。

**解题思路**

1. 哈希：用两个 HashMap 来完成，分别将字符和单词都映射到当前的位置加1，注意这里需要加 1 就是为了避免默认映射值 0，因为 C++ 中的 HashMap 的机制是若访问一个不存在的 key 值，会默认建立一个映射值为 0 的映射。

**边界条件**

1. s 和 p 长度不相等。

## 292

**题目描述**

Nim 游戏，给定一堆石子，每次可以拿 1~3 个，两个人轮流拿，拿到最后一个石子的人获胜，问先取者是否有必胜法。

**解题思路**

1. 尼姆博弈，只有石子数能被 4 整除即可。

## 295

**题目描述**

数据流中的中位数

**解题思路**

1. 大小堆
   - 最大堆存储数组的左半部分，最小堆存储数组的右半部分
   - 假定最大堆中存储的数量大于等于最小堆
   - 查询操作: 当前总数为奇数时，从最大堆中取出堆顶，否则同时取出最小堆和最大堆再取半
   - 同理，插入操作: 当前总数为奇数时，先插入最大堆，再弹出堆顶插入最小堆；当前总数为偶数时，先插入最小堆，再弹出堆顶插入最大堆。

## 297

**题目描述**

序列化和去序列化二叉树。序列化就是将一个数据结构或物体转化为一个位序列，可以存进一个文件或者内存缓冲器中，然后通过网络连接在相同的或者另一个电脑环境中被还原，还原的过程叫做去序列化。

**解题思路**

1. 先序遍历：序列化从根节点开始，如果节点存在，则将值存入输出字符串流，然后分别对其左右子节点递归调用序列化函数；去序列化先读入第一个字符，以此生成一个根节点，然后再对根节点的左右子节点递归调用去序列化函数。
2. 层序遍历：借助queue来做，本质是BFS算法

## 299

**题目描述**

针对一个四位数字猜一个结果，然后将猜的结果和真实结果做对比，提示有多少个数字和位置都正确的叫做bulls，还提示有多少数字正确但位置不对的叫做cows，实现以上机制，xAyB 表示有 A 个数字位置正确，B 个数字正确但是错位。

**解题思路**

1. 哈希表，主要用于处理 cows。
   - 如果secret当前位置数字的映射值小于0，则表示其在guess中出现过，cows自增1，然后映射值加1，
   - 如果guess当前位置的数字的映射值大于0，则表示其在secret中出现过，cows自增1，然后映射值减1

## 300

**题目描述**

最长递增子串

**解题思路**

1. 动态规划 O(n^2)：dp[i] 表示以 nums[i] 为结尾的最长递增子串的长度，对于每一个 nums[i]，从第一个数再搜索到 i，如果发现某个数小于 nums[i]，更新 dp[i]。$dp[i] = max(dp[i], dp[j] + 1)$。
2. 二分查找 O(nlogn)：先建立一个数组 ends，把首元素放进去，然后比较之后的元素
   - 如果遍历到的新元素比 ends 数组中的首元素小的话，替换首元素为此新元素
   - 如果遍历到的新元素比 ends 数组中的末尾元素还大的话，将此新元素添加到 ends 数组末尾(注意不覆盖原末尾元素)。
   - 如果遍历到的新元素比 ends 数组首元素大，比尾元素小时，此时用二分查找法找到第一个不小于此新元素的位置，覆盖掉位置的原来的数字。
   - ends 不是一个原数组的 LIS，只是长度相等而已
3. 二分查找+动态规划
   - 二分查找法在 dp 数组找第一个不小于它的数字
   - 如果这个数字不存在，那么直接在 dp 数组后面加上遍历到的数字
   - 如果存在，则将这个数字更新为当前遍历到的数字，最后返回 dp 数组的长度即可。
   - dp 数组的值可能不是一个真实的 LIS

**Follow Up**

1. 如果 LIS 不是严格递增
[[LintCode] Longest Increasing Subsequence 最长递增子序列 - Grandyang - 博客园](https://www.cnblogs.com/grandyang/p/4891500.html)
2. 如果要求出所有符合条件的子序列

## 303

**题目描述**

检索一个数组的某个区间的所有数字之和。数组元素不会发生变化。

**解题思路**

1. 累计直方图：建立一个累计和的数组 dp，其中 dp[i] 表示 [0, i] 区间的数字之和，那么 [i,j] 就可以表示为 dp[j]-dp[i-1]。

## 304

**题目描述**

检索一个二维数组的某个区域的所有数字之和。数组元素不会发生变化。

**解题思路**

1. 累计区域和：`dp[i][j]` 表示累计区间 (0, 0) 到 (i, j) 这个矩形区间所有的数字之和，(r1, c1) 到 (r2, c2) 的矩形区间和为 `dp[r2][c2] - dp[r2][c1 - 1] - dp[r1 - 1][c2] + dp[r1 - 1][c1 - 1]`。

## 310

**题目描述**

找到所有的最小高度树并返回他们的根节点。

**解题思路**

1. 基于拓扑排序：遍历所有的叶子节点，然后把这些叶子节点关联的边从图中删去，更新所有节点的度数，重复以上步骤，最后就能得到中心的节点。
2. DFS：问题求解其实可以转化为求图的直径（即图中的最长路径）

## 313

**题目描述**

超级丑数，质因子集合不一定是 (2,3,5)，自由指定。求给定质因子集合的第 n 个超级丑数。

**解题思路**

1. 参考 <264. Ugly Number II> 的做法，可以用一个idx数组来保存当前的位置，然后我们从每个子链中取出一个数，找出其中最小值，然后更新idx数组对应位置，注意有可能最小值不止一个，要更新所有最小值的位置。

**边界条件**

1. 注意 n 很大的情况下计算可能会发生溢出。

## 322

**题目描述**

给定一些可用的硬币面值，又给定总钱数，问最少能用几个硬币来找零。

**解题思路**

1. 动态规划：维护一个一维动态数组 dp，其中 dp[i] 表示钱数为i时的所需最少找零数。因为最小的硬币是1，所以 amount 最多需要 amount 个硬币，不可以用 INT_MAX 初始化，因为之后 +1 操作会溢出。状态转移方程为 $dp[i] = min(dp[i], dp[i - coins[j]] + 1)$
2. 递归+记忆数组：思路同上
3. 暴力搜索+剪枝：首先排序硬币数组，然后从最大硬币开始，尽可能取到最多，然后对于次一级的硬币进行递归。剪枝策略是若当前硬币数已超过最小值，停止检索并返回。

## 326

**题目描述**

判断一个数是不是3的次方数。

**解题思路**

1. 暴力解法: 不停地除以3，看最后的迭代商是否为1，要注意考虑输入是负数和0的情况。
2. 由于输入是int，正数范围是0-231，在此范围中允许的最大的3的次方数为3^19=1162261467，只要看这个数能否被n整除即可。
3. 换底公式
   - $log_{a}^{b} = log_{c}^{b} / log_{c}^{a}$，则 $log_{3}^{n} = log_{10}^{n} / log_{10}^{3}$
   - 如果 n 是 3 的倍数，则 $log_{3}^{n}$ 一定是整数
   - 所以只要判断 $log_{10}^{n} / log_{10}^{3}$ 是否为整数
   - C++ 中判断数字 a 是否为整数，可以用 `a - int(a) == 0` 来判断

**边界条件**

1. n 为 243
   - log(243) = 5.493061443340548
   - log(3) = 1.0986122886681098
   - log(243)/log(3) = 4.999999999999999
   - 由于判断依据是 log 后的结果是否是一个整数，如果用其他数作为 log 的底数，那计算出来应该是整数的 243 结果却不是整数，因为计算机在计算 log(3) 时实际上结果会稍微大一点点
   - 因此必须要使用log10这个函数，而不能用ln或者其他数字做底数的log函数

## 328

**题目描述**

给定一个单链表，把所有的奇数节点和偶数节点分别排在一起。所有奇节点在前，偶节点在后。

**解题思路**

1. 双指针
   - pre 指向奇节点，cur 指向偶节点
   - 偶节点 cur 后面的那个奇节点提前到 pre 的后面，然后 pre 和 cur 各自前进一步，此时 cur 又指向偶节点，pre 指向当前奇节点的末尾
   - 以此类推直至把所有的偶节点都提前即可
2. 奇偶指针
   - 奇偶指针分别指向奇偶节点的起始位置，另外需要一个单独的指针 even_head 来保存偶节点的起点位置
   - 把奇节点的指向偶节点的下一个(一定是奇节点)，此奇节点后移一步
   - 再把偶节点指向下一个奇节点的下一个(一定是偶节点)，此偶节点后移一步

## 329

**题目描述**

求矩阵中最长的递增路径，规定只能上下左右行走。

**解题思路**

1. DFS+记忆数组：`dp[i][j]` 表示数组中以 (i,j) 为起点的最长递增路径的长度
   - 初始将 dp 数组都赋为0，递归调用时遇到某个位置 (x, y), 如果 `dp[x][y]` 不为0的话，直接返回 dp[x][y] 即可
   - 以数组中每个位置都为起点调用递归来做，比较找出最大值。在以一个位置为起点用 DFS 搜索时，对其四个相邻位置进行判断，如果相邻位置的值大于上一个位置，则对相邻位置继续调用递归，并更新一个最大值，搜素完成后返回即可。
2. BFS+记忆数组：`dp[i][j]` 表示数组中以 (i,j) 为起点的最长递增路径的长度
   - 初始将 dp 数组都赋为0，递归调用时遇到某个位置 (x, y), 如果 `dp[x][y]` 不为0的话，直接返回 dp[x][y] 即可
   - 新建一个 queue，然后把当前点的坐标加进去，再用一个变量 cnt 初始化为 1，表示当前点为起点的递增长度，然后进入 while 循环。
   - 取出 queue 中的首元素，对周围四个点进行遍历，计算出相邻点的坐标后，要进行合法性检查，横纵坐标不能越界，且相邻点的值要大于当前点的值，并且相邻点的 dp 值要小于 cnt，才有更新的必要。用 cnt 来更新 `dp[x][y]`，并用 cnt 来更新结果 res，然后把相邻点排入 queue 中继续循环即可。

## 334

**题目描述**

判断数组中是否存在长度为 3 的递增子序列。要求 O(n) 时间复杂度和 O(1) 的空间复杂度。

**解题思路**

1. 使用两个指针 m1 和 m2，初始化为整型最大值，m1 表示最小值，m2 表示次小值。
   - 遍历数组，如果 m1 大于等于当前数字，将当前数字赋给 m1
   - 如果 m1 小于当前数字且 m2 大于等于当前数字，将当前数字赋给 m2，一旦 m2 被更新了，说明成功组成了一个长度为 2 的递增子序列
   - 接下来一旦遍历到比 m2 还大的数，直接返回ture。
   - 如果遇到比 m1 小的数还是要更新 m1，有可能的话也要更新 m2 为更小的值
2. 建立两个数组，forward 数组和 backward 数组
   - forward[i] 表示 [0, i] 之间最小的数
   - backward[i] 表示 [i, n-1] 之间最大的数
   - 对于任意一个位置 i，如果满足 forward[i] < nums[i] < backward[i]，表示这个递增三元子序列存在
   - 空间复杂度为 O(n)

## 336

**题目描述**

给定一组 互不相同 的单词，找出所有 不同 的索引对 (i, j)，使得列表中的两个单词，words[i] + words[j] ，可拼接成回文串。

**解题思路**

1. HashMap
   - 建立每个单词和其位置的映射，和一个 set 来保存出现过的单词的长度
   - 遍历单词集，对于遍历到的单词，对其翻转一下，然后在哈希表查找翻转后的字符串是否存在，注意不能和原字符串的坐标位置相同，因为有可能一个单词翻转后和原单词相等
   - 由于set是自动排序的，可以找到当前单词长度在set中的iterator，然后从开头开始遍历set，遍历比当前单词小的长度，比如abcdd翻转后为ddcba，发现set中有长度为3的单词，然后查看 dd 是否为回文串，若是，再看 cba 是否存在于哈希表，若存在，则说明 abcdd 和cba是回文对，存入结果中
   - 要在set里找的字符串要在遍历到的字符串的左边和右边分别尝试，看是否是回文对，这样遍历完单词集，就能得到所有的回文对

## 338

**题目描述**

给定 n，返回 0 到 n 所有数字中含 1 的个数。

**解题思路**

1. 位操作：通过 `a = a & (a - 1)` 将 a 的最右边 1 改为 0，从而可以通过已有的子问题求解

## 341

**题目描述**

给定一个嵌套的整数列表 nestedList，每个元素要么是一个整数，要么是一个列表，该列表的元素也可能是整数或者是其他列表。实现一个迭代器将其扁平化，使之能够遍历这个列表中的所有整数。

**解题思路**

1. 栈：从后往前把对象压入栈中，那么第一个对象最后压入栈就会第一个取出来处理。hasNext() 函数需要遍历栈，并进行处理，如果栈顶元素是整数，直接返回 true，如果不是，移除栈顶元素，并开始遍历这个取出的 list，还是从后往前压入栈，循环停止条件是栈为空，返回 false。
2. 双向队列：思路同上。

## 342

**题目描述**

解题思路

**解题思路**

1. 位操作：通过 $n & (n - 1)$ 可以用来判断一个数是否为2的次方数，在此基础上发现 4 的次方数的最高位的 1 都是奇数位，所以只需要让原数和 `(0x55555555) <==> 1010101010101010101010101010101` 取与验证得到的数还是其本身；或者在确定其是2的次方数了之后，发现只要是4的次方数，减1之后可以被3整除。

## 343

**题目描述**

给定一个正整数 n，将其拆分为至少两个正整数的和，并使这些整数的乘积最大化。

**解题思路**

1. 找规律
   - 将 n 拆分成 k 个数字，每个数字尽可能接近能取得最大乘积值
   - 当 n 固定时，随着 k 的增大，乘积值先增大后减小
2. [[LeetCode] 343. Integer Break · Issue #343 · grandyang/leetcode · GitHub](https://github.com/grandyang/leetcode/issues/343)

**边界条件**

1. n = 2 或 n = 3

## 344

**题目描述**

反转字符串。

**解题思路**

1. 按照题意处理即可。

## 345

**题目描述**

翻转字符串中的元音字母

**解题思路**

1. 双指针法

**边界条件**

1. 注意大写字母

## 347

**题目描述**

统计前 k 个高频的数字

**解题思路**

1. 建立数字到出现次数的映射。然后通过最大堆排序。

## 349

**题目描述**

找两个数组交集的部分（不包含重复数字）。

**解题思路**

1. HashSet：把 nums1 都放进 HashSet，然后遍历 nums2 的元素，如果在 HashSet 中存在，说明是交集的部分。
2. 排序+双指针：先给两个数组排序，然后用两个指针分别指向两个数组的开头，然后比较两个数组的大小，把小的数字的指针向后移，如果两个指针指的数字相等，那么看结果 res 是否为空，如果为空或者是最后一个数字和当前数字不等的话，将该数字加入结果 res 中。
3. 排序+二分查找：将一个数组排序，然后遍历另一个数组，把遍历到的每个数字在排序号的数组中用二分查找法搜索，如果能找到则放入结果 set 中。
4. STL的 set_intersection 函数。

## 350

**题目描述**

以数组形式返回两数组的交集，返回结果中每个元素出现的次数，应与元素在两个数组中都出现的次数一致。

**解题思路**

1. HashMap：建立 nums1 中字符和其出现个数之间的映射，然后遍历 nums2 数组，如果当前字符在 HashMap 中的个数大于0，则将此字符加入结果 res 中，然后 HashMap 的对应值自减 1。
2. 排序+双指针：先给两个数组排序，然后用两个指针分别指向两个数组的起始位置，如果两个指针指的数字相等，则存入结果中，两个指针均自增 1，如果第一个指针指的数字大，则第二个指针自增 1，反之亦然。

## 357

**题目描述**

找一个范围内的各位不相同的数字。

**解题思路**

1. 找规律

   ```txt
   k = 1    [0-9] 10
   k = 2    [10-99] 中去掉 [11,22,33,44,55,66,77,88,99] 9 * 9 = 81
   k = 3    [100-999] 9 * 9 * 8 = 648
   ...
   通项公式为 f(k) = 9 * 9 * 8 * ... (9 - k + 2)
   例外情况：k > 10, f(k) = 0
   ```

2. 回溯
   - 需要一个变量 used，其二进制第 i 位为 1 表示数字 i 出现过
   - 刚开始遍历 1 到 9，对于每个遍历到的数字，现在 used 中标记已经出现过，然后再调用递归函数。在递归函数中，如果这个数字小于最大值，则结果 res 自增1，否则返回res。
   - 然后遍历0到9，如果当前数字没有在 used 中出现过，此时在 used 中标记，然后给当前数字乘以10加上i，再继续调用递归函数，这样可以遍历到所有的情况

## 365

**题目描述**

有两个容量分别为 x 升 和 y 升 的水壶以及无限多的水，能否通过这两个水壶得到恰好 z 升的水？

问题其实可以转换为有一个很大的容器，有两个杯子，容量分别为 x 和 y，问通过用两个杯子往里倒水，和往出舀水，问能不能使容器中的水刚好为z升。那么这里可以用一个公式来表达：

$$z = m * x + n * y$$

其中 m，n 为舀水和倒水的次数，正数表示往里舀水，负数表示往外倒水。

根据裴蜀定理，等式 $ax + by = d$ 中的 x 和 y 有解的 d 最小正值为 `gcd(x, y)`，当 d 为 gcd(x, y) 的倍数时，也是有解的。所以只要 `z % gcd(x, y) == 0`，上面的等式就有解。

除此还有个限制条件 `x + y >= z`，因为 x 和 y 不可能称出比它们之和还多的水。

**解题思路**

1. 计算 `z % gcd(x, y) == 0` 即可。

## 367

**题目描述**

判断完全平方数。

**解题思路**

1. 穷举：从 1 搜索到 sqrt(num)，看有没有平方正好等于 num 的数。
2. 二分查找
3. 完全平方数是一系列奇数之和。时间复杂度为 O(sqrt(n))。

   ```txt
   1 = 1
   4 = 1 + 3
   9 = 1 + 3 + 5
   16 = 1 + 3 + 5 + 7
   25 = 1 + 3 + 5 + 7 + 9
   36 = 1 + 3 + 5 + 7 + 9 + 11
   ....
   1 + 3 + ... + (2n-1) = (2n - 1 + 1)*n/2 = n * n
   ```

4. 牛顿迭代法
5. Q_rsqrt 算法：O(1) 时间复杂度。

## 371

**题目描述**

不依赖内建操作符实现加法运算。

**解题思路**

1. 位操作
   - 考虑例子 759+674，只考虑进位结果为 323，不考虑进位结果为 1110，两个结果数字相加是最终结果
   - 只考虑进位为‘与’运算，不考虑进位为‘异或’运算，得到两个结果后再次相加时可以递归调用，终止条件为进位为 0。

**边界条件**

1. LeetCode编译器不能对负数进行左移，最高位符号位必须要为0。

## 374

**题目描述**

猜价格，根据对方说高了还是低了来缩小范围

**解题思路**

1. 二分搜索

## 378

**题目描述**

一个 n x n 矩阵 matrix ，其中每行和每列元素均按升序排序，找到矩阵中第 k 小的元素。

**解题思路**

1. 二分查找
   - 由于是有序矩阵，那么左上角的数字一定是最小的，而右下角的数字一定是最大的，从而得到搜索范围
   - 在每一行都查找第一个大于 mid 的数字，如果目标数在比该行的尾元素大，返回该行元素的个数，如果目标数比该行首元素小，返回 0
   - 遍历完所有的行可以找出中间数是第几小的数，然后和 k 比较，进行二分查找，left 和 right 最终会相等，并且会变成数组中第 k 小的数字。
   - 时间复杂度为 O(nlgn*lgX)，其中 X 为最大值和最小值的差值
2. 二分查找进一步优化，利用每列有序的性质
   - 从数组的左下角开始查找，如果比目标值小，就向右移一位，而且当前列的当前位置的上面所有的数字都小于目标值，那么 cnt += (i + 1)，反之则向上移一位，这样也能算出 cnt 的值
   - 时间复杂度为 O(nlgX)，其中 X 为最大值和最小值的差值

## 380

**题目描述**

在常数时间范围内实现插入删除和获得随机数操作，*不允许*有重复数字

**解题思路**

1. 维护一个一维数组和一个 HashMap，其中数组用来保存数字，HashMap 用来建立每个数字和其在数组中的位置之间的映射
   - 对于插入操作，先看这个数字是否已经在 HashMap 中存在，如果存在的话直接返回 false，不存在的话，将其插入到数组的末尾，然后建立数字和其位置的映射。
   - 对于删除操作，先判断其是否在 HashMap 里，如果没有直接返回 false。了使数组删除也能常数级，将要删除的数字和数组的最后一个数字调换个位置，然后修改对应的 HashMap 中的值，这样只需要删除数组的最后一个元素即可
   - 针对返回随机数操作，只要随机生成一个位置，返回该位置上的数字

## 381

**题目描述**

在常数时间范围内实现插入删除和获得随机数操作，*允许*有重复数字

**解题思路**

1. 参见 <380> 的做法，只不过需要用哈希set存储多个同样值的数组下标。
2. 进一步节约空间，nums改成 `vector<pair<int,int>>`, 第二个int记录这个值在 map 对应的 vector 中的 index。

## 382

**题目描述**

随机返回一个链表节点，链表可能会很长，即只允许一次遍历。

**解题思路**

1. 水塘抽样: 维护一个大小为1的水塘

## 383

**题目描述**

需要从杂志上剪贴字到勒索信上，判断是够可行。

**解题思路**

1. HashMap: 统计字符的个数

## 384

**题目描述**

数组随机打乱

**解题思路**

1. 洗牌算法 Knuth-Durstenfeld Shuffle

## 387

**题目描述**

返回第一个非重复字符的下标

**解题思路**

1. 用一个数组记录每个字母出现的次数。

## 390

**题目描述**

一个 1-n 的有序数组，从左开始每隔一个数进行删除，然后从最右开始以同样方法进行删除，循环反复后只剩下一个数字，求出该数字。

**解题思路**

1. 从左往右删的时候，每次都是删掉第一个数字，而从右往左删的时候，则有可能删掉第一个或者第二个数字（剩下数字是偶数个时，删掉的是第二个数字），而且每删一次，数字之间的距离会变为之前的两倍，所以只需要记录每次删减后数组的第一个数字即可。
2. 递归：第一次从左往右删除的时候，奇数都被删掉了，剩下的都是偶数。如果对所有数都除以 2，那么得到一个 1 到 n/2 的新数列。下一次从右往左删除，那么返回的结果应该是调用递归的结果 lastRemaining(n/2) 在数组 1 到 n/2 之间的镜像。何为镜像，比如 1, 2, 3, 4 这个数字，2 的镜像就是 3, 1 的镜像是 4。

## 392

**题目描述**

给定两个字符串 s 和 t，判断 s 是不是 t 的子序列(不一定连续)。

**解题思路**

1. 用两个指针分别指向字符串 s 和 t，然后如果字符相等，则 i 和 j 自增1，反之只有 j 自增1，最后看 i 是否等于 s 的长度。

**Follow up**

1. 如果 s 是一个字符串集合，判断集合中是否有 t 的子序列，如何优化。

## 393

**题目描述**

检验 UTF-8 编码。

[UTF-8 - 维基百科，自由的百科全书](https://zh.wikipedia.org/wiki/UTF-8)

对于 UTF-8 编码中的任意字节 B

- 如果 B 的第一位为0，则 B 独立的表示一个字符(ASCII 码)；
- 如果B的第一位为 1，第二位为 0，则 B 为一个多字节字符中的一个字节(非 ASCII 字符)；
- 如果 B 的前两位为 1，第三位为 0，则 B 为两个字节表示的字符中的第一个字节；
- 如果 B 的前三位为 1，第四位为 0，则 B 为三个字节表示的字符中的第一个字节；
- 如果 B 的前四位为 1，第五位为 0，则 B 为四个字节表示的字符中的第一个字节；

因此，对 UTF-8 编码中的任意字节，根据第一位，可判断是否为 ASCII 字符；根据前二位，可判断该字节是否为一个字符编码的第一个字节；根据前四位（如果前两位均为1），可确定该字节为字符编码的第一个字节，并且可判断对应的字符由几个字节表示；根据前五位（如果前四位为1），可判断编码是否有错误或数据传输过程中是否有错误。

**解题思路**

1. 位操作
   - 验证一个数字某几位的方法可以用 !(a & mask ^ target)。
   - 用一个指示变量记录当前 UTF-8 所需要记录的字节数，如果指示变量为 0，表示进入了新的一轮识别，需要通过验证判断当前字节数；如果大于0，说明是次字节或次次字节或次次次字节，需要判断是否合法。

## 394

**题目描述**

解码字符串，字符串形如 "2[abc]3[cd]ef"，解码后得到 "abcabccdcdcdef"

**解题思路**

1. 迭代+栈
   - 两个栈，分别存储数字和当前字符串。当遇到 ']' 时，不断让字符串弹出直至遇到 '['，然后拼接这些字符串，并重复数字栈最顶端数字的次数。
   - 为了方便处理，对于初始字符串左右两边做了下处理变成 "1[s]" 的形式。

## 395

**题目描述**

给定一个字符串 s 和一个整数 k，找出 s 中的最长子串，要求该子串中的每一字符出现次数都不少于 k。

**解题思路**

1. 滑动窗口
   - 字符串中只有字母，这意味着最多不同的字母数只有 26 个，最后满足题意的子串中的不同字母数一定是在 [1, 26] 的范围
   - 每次只找不同字母个数为 cnt，且每个字母至少重复 k 次的子串，来更新最终结果 res。
   - cnt 从 1 遍历到 26，对于每个 cnt 都新建一个大小为 26 的数组 charCnt 来记录每个字母的出现次数
   - 用两个变量 start 和 i 来分别标记窗口的左右边界，当右边界小于 n 时，进行 while 循环，需要一个变量 valid 来表示当前子串是否满足题意
   - 需要一个变量 uniqueCnt 来记录子串中不同字母的个数。此时若 s[i] 这个字母在 charCnt 中的出现次数为 0，说明遇到新字母了，uniqueCnt 自增1，同时把该字母的映射值加 1。
   - 由于 uniqueCnt 变大，有可能会超过 cnt，所以这里用一个 while 循环，条件是当 uniqueCnt 大于 cnt ，此时应该收缩滑动窗口的左边界
   - 当 uniqueCnt 没超过 cnt 的时候，此时还要看当前窗口中的每个字母的出现次数是否都大于等于 k，遇到小于 k 的字母，则直接 valid 标记为 false 即可

TODO

## 400

**题目描述**

自然数序列看成一个长字符串，求第 N 位上的数字。

**解题思路**

1. 定义个变量 cnt 初始化为9，每次循环扩大 10 倍，再用一个变量 len 记录当前循环区间数字的位数，另外再需要一个变量 start 用来记录当前循环区间的第一个数字。当 n 落到某一个确定的区间里了，`(n-1)/len` 就是目标数字在该区间里的坐标，加上 start 就是得到了目标数字，然后将目标数字 start 转为字符串，`(n-1)%len` 就是所要求的目标位。

## 401

**题目描述**

二进制表，通过 10 个 led 灯显示当前时间。前 4 个表示小时 (0-11)，后六个表示分钟 (0-59)，指定亮灯的个数，求可能的时间集合。

**解题思路**

1. bitset
   - 问题实质求十进制数如果用二进制表示有多少个 ‘1’ 的问题。
   - bitset 类可以将任意进制数转为二进制，而且又用到了count函数，用来统计 1 的个数。那么时针从 0 遍历到 11，分针从 0 遍历到 59，然后把时针的数组左移6位加上分针的数值，然后统计1的个数，即为亮灯的个数。

## 403

**题目描述**

一只青蛙想要过河，假定河流被等分为若干个单元格，并且在每一个单元格内都有可能放有一块石子。 青蛙可以跳上石子，但是不可以跳入水中。

给定石子的位置列表 stones（用单元格序号 升序 表示），判定青蛙能否成功过河（即能否在最后一步跳至最后一块石子上）。开始时，青蛙默认已站在第一块石子上，并可以假定它第一步只能跳跃 1 个单位。

如果青蛙上一步跳跃了 k 个单位，那么它接下来的跳跃距离只能选择为 k - 1、k 或 k + 1 个单位。 另请注意，青蛙只能向前方（终点的方向）跳跃。

**解题思路**

1. DFS + 二分查找 + 记忆数组
   - 青蛙从每个位置起跳时都带有两个状态：当前位置和跳到当前位置的跳力
   - 记忆数组的 key 为位置和跳力的拼接值，值为是否能够跳到最后一个位置
   - 为了快速判断下一跳是否能跳到石子上，需要通过二分查找判断位置是否在石子数组中
   - 需要注意最开始位置的跳力为 0
   - 因为只能往前前走，跳力必须大于 0

## 404

**题目描述**

计算二叉树所有左叶子节点的和

**解题思路**

1. 需要传递一个标志位，因为一个节点是否为左节点是由父节点决定的。
2. 直接在原函数中检查当前节点的左子节点是否是左子叶，如果是的话，则返回左子叶的值加上对当前结点的右子节点调用递归的结果；如果不是的话，对左右子节点分别调用递归函数，返回二者之和。

## 409

**题目描述**

给定一个包含大写字母和小写字母的字符串，找到通过这些字母构造成的最长的回文串。

**解题思路**

1. 问题转化为求偶数个字符的个数。

## 412

**题目描述**

将 3 的倍数替换为 Fizz，5 的倍数替换为 Buzz，15 的倍数替换为 FizzBuzz。

**解题思路**

1. 依题意处理即可。

## 414

**题目描述**

求数组中第三大的数，要求 O(n) 时间复杂度。

**解题思路**

1. 初始化三个数字为最小值，因为有可能出现INT_MIN，所以要用LLONG_MIN。然后根据每次迭代的数字依次更新三个候选数。需要注意的是等于候选数的数字。

**边界条件**

1. 数组长度小于3
2. 数组中独特数字数量小于3
3. INT_MIN 在数组中

## 416

**题目描述**

给定一个只包含正整数的非空数组 nums，判断是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。

**解题思路**

1. 动态规划
   - dp[i] 表示原数组是否可以取出若干个数字，其和为 i，dp[0] 为 true
   - 状态转移方程 `dp[j] = dp[j] || dp[j - nums[i]]  (nums[i] <= j <= target)`
2. bitset
   - 第 i 位表示数组中是否能取出若干个数字，其和为 i
   - 数组的长度不超过 200，每个数字的大小都不会超过 100，最大的和为 20000，一半就是 10000，bitset 长度最多不会超过 10001
   - 对于遍历到的数字 num，把 bits 向左平移 num 位，然后再或上原来的 bits，这样所有的可能出现的和位置上都为 1
   - 遍历完整个数组后，查看 bits[sum >> 1] 是否为 1

## 434

**题目描述**

统计字符串中的单词数量，单词以空格进行分隔

**解题思路**

1. 遍历字符串，遇到空格直接跳过，如果不是空格，则计数器加1，然后用个while循环找到下一个空格的位置。
2. 统计单词开头的第一个字符，因为每个单词的第一个字符前面一个字符一定是空格。
3. 利用 C++ 的 getline 函数取出每两个空格符之间的字符串，由于多个空格符可能连在一起，所以有可能取出空字符串，只有取出的是非空字符串才累加计数器。

## 435

**题目描述**

给定一个区间的集合，找到需要移除区间的最小数量，使剩余区间互不重叠。

**解题思路**

1. 贪心算法：为了保证总体去掉的区间数最小，去掉 end 值较大的区间。

## 438

**题目描述**

给定两个字符串 s 和 p，找到 s 中所有 p 的 异位词 的子串，返回这些子串的起始索引。异位词 指由相同字母重排列形成的字符串（包括相同的字符串）。

**解题思路**

1. 滑动窗口 + HashMap：两个变量 left 和 right 表示滑动窗口的左右边界，HashMap 用于存储 p 中字符的出现频率。

## 442

**题目描述**

数组范围在 [1, n]，数组中的数字可能出现一次或两次，找出所有出现两次的数字。要求 O(1) 空间复杂度，O(n) 时间复杂度。

**解题思路**

1. 取负法：将元素对应的位置取负。在取负的过程中，如果发现要取负的位置已经为负，说明这个元素已经出现过，也即该元素出现了两次。当某个元素不出现的时候，该元素对应的位置始终访问不到，所以还是正值。
2. 将 nums[i] 置换到其对应的位置 nums[nums[i]-1]。最后在对应位置检验，如果 nums[i] 和 i+1 不等，将 nums[i] 存入结果 res 中即可。

## 445

**题目描述**

两个非空链表代表两个非负整数，数字最高位位于链表开始位置，它们的每个节点只存储一位数字，将这两数相加会返回一个新的链表。除了数字 0 之外，这两个数字都不会以零开头。

**解题思路**

1. 栈：利用栈来保存所有的元素，然后利用栈的后进先出的特点就可以从后往前取数字。建立一个值为0的 res 节点，然后开始循环，如果栈不为空，则将栈顶数字加入 sum 中，然后将 res 节点值赋为 sum%10，然后新建一个进位节点 head，赋值为 sum/10，如果没有进位，那么就是0，然后在 head 后面连上 res，将 res 指向 head，这样循环退出后，我们只要看 res 的值是否为 0，为 0 返回 res->next，不为 0 则返回 res 即可。
2. 递归：首先统计出两个链表长度，然后根据长度来调用递归函数，需要传一个参数差值，递归函数参数中的 l1 链表长度长于 l2。

## 448

**题目描述**

给定长度为 n 的数组，数值范围为 [1, n]，数字最多重复出现两次，找到所有消失的数字。要求 O(n) 时间复杂度，且不使用额外的空间。

**解题思路**

1. 取负法：将元素对应的位置取负。在取负的过程中，如果发现要取负的位置已经为负，说明这个元素已经出现过，也即该元素出现了两次。当某个元素不出现的时候，该元素对应的位置始终访问不到，所以还是正值，通过这种方法我们就可以找到哪些元素没有出现。

## 454

**题目描述**

在四个数组中各取一个数字使总和为 0，一共有多少种取法。

**解题思路**

1. HashMap: 把 A 和 B 的两两之和都求出来，在 HashMap 中建立两数之和跟其出现次数之间的映射，那么再遍历 C 和 D 中任意两个数之和，再看看哈希表存不存在这两数之和的相反数。时间复杂度为 O(n^2)。

## 455

**题目描述**

饼干分配问题，给定两个数组，分别表示每个小孩期望的饼干尺寸，和每个饼干实际的尺寸。将饼干分配给这些小孩，但分配的饼干尺寸必须不小于小孩期望的饼干尺寸。求出这些饼干最多可以满足几个小孩。

**解题思路**

1. 贪心策略：首先对两个数组进行排序。只有满足了当前的小朋友，才会去满足下一个胃口较大的小朋友。

## 461

**题目描述**

求两个数的汉明距离，汉明距离即二进制数对应位不同的个数。

**解题思路**

1. 位操作：异或后求 1 的个数，可以通过 $a & (a - 1)$ 将 a 最右边的 1 转为 0。

## 463

**题目描述**

若干连在一起的格子形成了一个小岛，规定了图中只有一个相连的岛，且岛中没有湖，求岛的周长。

**解题思路**

![463 Island Perimeter](https://gitlab.com/convexwf/convex-resource/-/raw/master/convex-notes/leetcode-463_Island_Perimeter.png)

1. 以边作为考虑对象，单独对边进行处理
   - 针对左边的边，只有当左边的边处于第一个位置或者当前格子的左面没有岛格子的时候，左边的边计入周长
   - 其他边分析情况类似
2. 对于每个岛屿格子先默认加上四条边，然后检查其左面和上面是否有岛屿格子，有的话分别减去两条边。因为遍历方向是从左到右从上到下，所以只需要检查左边和上边的情况。

## 464

**题目描述**

给定两个整数 maxChoosableInteger(整数池中可选择的最大数) 和 desiredTotal(累计和)，两个玩家可以轮流从公共整数池中抽取整数(不放回)，先使得累计整数和达到或超过规定累计和的玩家即为胜者。求先手玩家是否必胜。

**解题思路**

1. HashMap + 递归
   - 如果给定的数字范围大于等于目标值的话，直接返回 true。如果给定的数字总和小于目标值的话，说明谁也没法赢，返回 false。
   - 进入递归函数，首先查找当前情况是否在 HashMap 中存在，有的话直接返回即可。
   - 使用一个整型数按位来记录数组中的某个数字是否使用过，遍历所有数字，将该数字对应的 mask 算出来，如果其和 used 相与为 0 的话，说明该数字没有使用过
   - 如果此时的目标值小于等于当前数字，说明已经赢了，或者调用递归函数，如果返回 false，说明也是当前进入递归函数的玩家赢了。

## 470

**题目描述**

通过 rand7(1～7) 构造 rand10(1～10)

**解题思路**

拒绝采样 Rejection Sampling: 随机到需要的数字就接受，不是需要的就拒绝，并重新采样。

1. 通过 rand7(1～7) 生成 rand49(1～49)，大于 40 的直接拒绝并重新采样
2. 上述方法的递归形式
3. 进一步优化: 在 [1, 49] 的范围内随机到 [41, 49] 内的数字概率还是很高
   - 将采样到的数字减去 40 得到 rand9()
   - (rand9() - 1) * 7 + rand7() 获得 rand63()
   - rand63() 拒绝采样得到 rand3()
   - (rand3() - 1) * 7 + rand7() 得到 rand21()
   - rand21() 拒绝采样得到 rand20()，进而得到 rand10()

## 476

**题目描述**

求补数，即最高位的 1 开始翻转位。

**解题思路**

1. 位操作，增加一个变量 flag 标识当前是否遇到高位 1
   - 从高位往低位遍历，如果遇到 1 之后就把 flag 置为 true
   - 仅当 flag 后才对位取反，取反方式为对应位与 1 异或
2. 位操作，用一个 mask 来标记最高位 1 前面的所有 0 的位置，然后将 mask 取反，和对num取反的结果做与操作即可。
3. 迭代: 每次都右移一位，并根据最低位的值先进行翻转，如果当前值小于等于1，就不用再调用递归函数了

## 477

**题目描述**

计算数字集合中每个两两数字对汉明距离的总和。

**解题思路**

1. 位操作：找到每一位上 1 的个数和 0 的个数，然后两个相乘即这一位的总 Hamming Distance

## 478

**题目描述**

给定一个圆的中心和半径，随机生成圆中的一个点

**解题思路**

1. 拒绝采样: 在一个正方形中有均匀分布的点，随机出其内切圆中的一个点，就是随机出x和y之后算平方和，如果小于等于 r 平方，说明其在圆内，可以返回其坐标，记得加上圆心偏移，否则重新进行采样。
2. 极坐标: 随机出角度 theta 和一个小于半径的长度 r。注意取 r 时需要取个平方根。

## 482

**题目描述**

对注册码进行格式化，正确的注册码的格式是每四个字符后面跟一个短杠，每一部分的长度为K，第一部分长度可以小于K，另外，字母必须是大写的。

**解题思路**

1. 首先计算出有效字符的个数。

**边界条件**

1. k 正好可以整除 n
2. 小写字母需要转为大写字母

## 485

**题目描述**

求二进制数组中最大连续 1 的个数。

**解题思路**

1. 遍历一遍数组，用一个计数器 cnt 来统计 1 的个数
2. 数组中的数字只能是 0 或 1，那么连续 1 的和跟个数相等，所以可以计算和，通过加上 num，再乘以 num 来计算

## 492

**题目描述**

根据面积求出矩形的长和宽，要求长和宽的差距尽量的小，即越接近正方形越好。

**解题思路**

1. 开方运算 sqrt: 从 (int)sqrt(area) 遍历到 1作为矩形的高度。

## 495

**题目描述**

提莫攻击，每一次攻击都会造成敌人中毒，中毒的时间不会累计，求若干次攻击后总共的中毒时间。

**解题思路**

1. 按照题意处理即可。将紧接着的两个数字做减法，并和持续时间做对比。

## 496

**题目描述**

给定一个数组，又给了该数组的一个子集合，求集合中每个数字在原数组中右边第一个较大的数字。

**解题思路**

1. HashMap+单调栈
   - 建立每个数字和其右边第一个较大数之间的映射
   - 遍历原数组中的所有数字，如果此时栈不为空，且栈顶元素小于当前数字，说明当前数字就是栈顶元素的右边第一个较大数，那么建立二者的映射，并且去除当前栈顶元素，最后将当前遍历到的数字压入栈。
   - 当所有数字都建立了映射，最后可以直接通过哈希表快速的找到子集合中数字的右边较大值

## 500

**题目描述**

哪些单词可以由键盘上的一行中的键符打出来。

**解题思路**

1. 把键盘的三行字符分别保存到三个set中，然后遍历每个单词中的每个字符，分别看当前字符是否在三个集合中，如果在，对应的标识变量变为1，最后统计三个标识变量之和就知道有几个集合参与其中。

## 501

**题目描述**

求二分搜索树中的众数。

**解题思路**

1. 先序遍历+哈希表计数
2. 递归中序遍历:不用除了递归中的隐含栈之外的额外空间。二分搜索树的中序遍历结果是有序的。
3. 迭代中序遍历。

## 503

**题目描述**

给定一个 *循环* 数组，又给了该数组的一个子集合，求集合中每个数字在原数组中右边第一个较大的数字。

**解题思路**

1. HashMap+单调栈，参见 <496. Next Greater Element I>
   - 遍历两遍数组，但是只在第一次遍历时压栈，因为超过 n 的部分只是为了给之前栈中的数字找较大值

## 504

**题目描述**

十进制转为七进制，输入可能是负数。

**解题思路**

1. 进制转换。注意 0 和负数的处理。

## 506

**题目描述**

给定一组分数，求相对排名，前三名分别是金银铜牌，后面的就是名次数。

**解题思路**

1. 哈希表：首先存储元素到下标的映射，然后对数组进行降序排序。
2. 利用堆来排序，建立一个优先队列，把分数和其坐标位置放入队列中。
3. map：对方法 1 直接进行简化，使用红黑树直接合并映射和排序。

## 507

**题目描述**

完数 = 自身所有因子（不包括数字本身）之和

**解题思路**

1. 从 1 计数到 sqrt(n)，然后计数所有 i 和 n/i。

**边界条件**

1. 1 不属于完数。

## 509

**题目描述**

斐波那契数列

**解题思路**

undefined

## 516

**题目描述**

最长回文子序列。

**解题思路**

1. 动态规划
   - `dp[i][j]` 表示 s.substr(i, j) 的最大子序列长度
   - 初始状态：`dp[i][i] = true`
   - 状态转移方程：`dp[i][j] = dp[i+1][j-1] + 2 if s[i] = s[j] else max(dp[i+1][j], dp[i][j-1])`
   - 遍历顺序：从小区间遍历到大区间

## 520

**题目描述**

检测单词的大写格式是否正确，规定了三种正确方式，要么都是大写或小写，要么首字母大写，其他情况都不正确。

**解题思路**

1. 状态机：![520 状态机](https://gitlab.com/convexwf/convex-resource/-/raw/master/convex-notes/leetcode-520_状态机.png)
2. 统计出单词中所有大写字母的个数 cnt，再来判断是否属于这三种情况。

## 532

**题目描述**

给定一个含有重复数字的无序数组，还有一个整数k，让找出有多少对不重复的数对 (i, j) 使得 i 和 j 的差刚好为 k。注意，(i, j) 和 (j, i) 是一样的。

**解题思路**

1. HashMap:
   - 建立每个数字和其出现次数之间的映射
   - 如果 k 为 0 且该数字出现的次数大于 1，则结果 res 自增1
   - 如果 k 不为 0，且用当前数字加上 k 后得到的新数字也在数组中存在，则结果 res 自增 1。

## 543

**题目描述**

求二叉树的直径，直径即两点之间的最远距离。

**解题思路**

1. 对每一个结点求出其左右子树深度之和，然后再对左右子结点分别调用求直径对递归函数，这三个值相互比较，取最大的值更新结果 res，因为直径不一定会经过根结点，所以才要对左右子结点再分别算一次。为了减少重复计算，用哈希表建立每个结点和其深度之间的映射。
2. TODO 两次 DFS 或树型dp：[树的直径 - OI Wiki](https://oi-wiki.org/graph/tree-diameter/)

## 547

**题目描述**

班上有 N 名学生，其中有些人是朋友，有些则不是。他们的友谊具有传递性，如果已知 A 是 B 的朋友，B 是 C 的朋友，可以认为 A 也是 C 的朋友。朋友圈指所有朋友的集合。给定一个 N * N 的矩阵 M，表示班级中学生之间的朋友关系，如果 `M[i][j] = 1`，表示已知第 i 个和 j 个学生互为朋友关系，否则为不知道。输出所有学生中的已知的朋友圈总数。

**解题思路**

1. 并查集：并查集的特点是孩子结点指向父亲结点，两个结点连接在一起即它们有相同的根结点。
   - 初始时给每一个对象都赋上不同的标签，然后对于属于同一类的对象，在 root 中查找其标签，如果不同，那么将其中一个对象的标签赋值给另一个对象
   - 初始设置朋友圈个数为 n，每次发现两个对象标签不一致时，朋友圈个数减 1

## 551

**题目描述**

给定学生的出勤情况，A 表示出勤，L 表示吃到，P 表示缺席，只要超过 1 次缺席或者连续三次以上迟到就判定为 true。

**解题思路**

1. 分别记录缺勤和连续迟到的次数
   - 如果遇到缺勤，缺勤计数器自增 1，连续迟到计数器清零
   - 如果遇到迟到，连续迟到计数器自增1
   - 如果遇到正常出勤，连续迟到计数器清零。
2. 正则匹配。
   - 匹配式是 `A.*A|LLL`
   - `.*` 表示有零个或者多个
   - `A.*A` 就是至少有两 A 的情况
   - `LLL` 是三个连续的迟到
   - `|` 表示两个是或的关系

**边界条件**

1. 第一天迟到第二天缺勤，迟到天数会清零。

## 554

**题目描述**

给定一个砖头墙壁，上面由不同的长度的砖头组成，选个地方从上往下把墙劈开，使得被劈开的砖头个数最少，前提是不能从墙壁的两边劈。

**解题思路**

![554 Brick Wall](https://gitlab.com/convexwf/convex-resource/-/raw/master/convex-notes/leetcode-554_Brick_Wall.png)

1. HashMap
   - 建立每一个断点的长度和其出现频率之间的映射，这样只要从断点频率出现最多的地方劈墙，损坏的板砖一定最少。

## 556

**题目描述**

对给定数字的各个位数重新排序，求刚好比给定数字大的一种排序，如果不存在就返回-1。

**解题思路**

1. 参见 <31. Next Permutation>

**边界条件**

1. 转换后的数字可能会越界
2. 输入 n 已经是最大值，没有下一个较大的数字

## 557

**题目描述**

翻转字符串中的每个单词，单词被单空格分隔，且前后没有多余空格。

**解题思路**

1. 栈：遇到字符就压入栈，遇到空格就出栈
2. 双指针法：O(1) 空间复杂度。

## 560

**题目描述**

让求和为 k 的连续子数组的个数。

**解题思路**

1. HashMap：建立连续子数组之和跟其出现次数之间的映射，初始化要加入 {0,1} 这对映射。建立哈希表的目的是为了快速查找 sum-k 是否存在，即是否有连续子数组的和为 sum-k，如果存在的话，那么和为 k 的子数组一定也存在。

## 563

**题目描述**

求二叉树的坡度，某个结点的坡度的定义为该结点的左子树之和与右子树之和的差的绝对值。

**解题思路**

1. 后续遍历：返回值为当前子树的结点之和，所以需要一个参数来专门记录坡度和。

## 566

**题目描述**

实现矩阵大小的重塑，即实现 reshape 函数。

**解题思路**

1. 将原数组拉直，然后再组成新的数组。

**边界条件**

1. 两者的元素总数不相同。

## 575

**题目描述**

一堆糖，每种糖的个数不定，平均分给两个人，求其中一个人能拿到的最大的糖的种类数。

**解题思路**

1. 每人得到 n/2 块糖，那么能拿到的最大的糖的种类数也就是 n／2 种。利用集合 set 的自动去重复特性来求出糖的种类数，然后跟 n/2 比较，取二者之中的较小值返回即可

## 581

**题目描述**

最短的无序连续子数组，乱序数组中，只排序某个部分的子数组就能让整体有序，求子数组的最短长度。

**解题思路**

1. 滑动窗口: 遍历数组，只要当前数字小于前面的最大值，就说明当前数字需要加入排序，而且由于当前数字的加入，左边界窗口可能向左移，把所有比其大的数字都加入需要排序的滑动窗口。
2. 分解为两个子问题，分别找出乱序子数组的开始位置和结束位置。
   - 从左到右遍历，只要当前值小于最大值，说明当前位置需要重新排序，结束位置必须大于等于当前位置
   - 从右到左遍历，只要当前值大于最小值，说明当前位置需要重新排序，开始位置必须小于于等于当前位置
   - 上述两个遍历可以在一个循环中实现

## 589

**题目描述**

N 叉树的前序遍历。

**解题思路**

1. 递归
2. 迭代

## 590

**题目描述**

N 叉树的后序遍历。

**解题思路**

1. 递归
2. 迭代

## 593

**题目描述**

验证这四个点是否能组成一个正方形

**解题思路**

正方形的四条边相等，两条对角线相等，满足这两个条件的四边形一定是正方形。

1. HashMap
   - 对四个点，两两之间算距离
   - 如果计算出某两个点之间距离为 0，说明两点重合了，直接返回 false
   - 如果不为 0，那么就建立距离和其出现次数之间的映射
   - 最后如果我们只得到了两个不同的距离长度，那么就说明是正方形。
2. HashSet: 集合中不存在0，且里面只有两个数的时候，说明是正方形

## 594

**题目描述**

找出最长的和谐子序列，和谐子序列就是序列中数组的最大最小差值均为 1

**解题思路**

1. treemap(红黑树): 建立一个数字和其出现次数之间的映射，从第二个映射对开始遍历，每次跟其前面的映射对比较，如果二者的数字刚好差1，那么就把二个数字的出现的次数相加并更新结果 res 即可
2. 哈希表: 建立每个数字跟其出现次数之间的映射，然后再遍历每个数字的时候，只需在 HashMap 中查找该数字加1是否存在，存在就更新结果 res。
3. 方法2的进一步优化到在一个循环内。
4. 排序+滑动窗口

## 605

**题目描述**

给定一个 01 数组，其中 1 表示已经放了花，0 表示可以放花的位置，不能有相邻的花，求是否还能放下额外 n 盆花

**解题思路**

1. 如果有 3 个连续的零，可以放下 1 盆花，如果左右是边界的话，可以放 2 盆花。必须要对边界进行处理，如果首位置是0，那么前面再加上个0，如果末位置是0，就在最后面再加上个0。这样处理之后我们就默认连续0的左右两边都是1了，这样如果有k个连续0，那么就可以通过(k-1)/2来快速计算出能放的花的数量。
2. 为了不特殊处理首末位置，直接先在首尾各加了一个0，然后就三个三个的来遍历，如果找到了三个连续的0，那么n自减1，i自增1，这样相当于i一下向后跨了两步。

## 606

**题目描述**

创建二叉树对应的字符串。如果左子结点为空，右子结点不为空时，需要在父结点后加上个空括号，而右子结点如果不存在，或者左右子结点都不存在就不需要这么做。

**解题思路**

1. 递归
   - 如果左右结果串均为空，则直接返回当前结点值
   - 如果左子结果串为空，那么返回当前结果 res，加上一个空括号，再加上放在括号中的右子结果串
   - 如果右子结果串为空，那么发返回当前结果res，加上放在括号中的左子结果串
   - 如果左右子结果串都存在，那么返回当前结果，加上分别放在括号中的左右子结果串

## 611

**题目描述**

给定非负数组，能组成多少个正确的三角形。

三角形任意两条边之和要大于第三边，问题其实就变成了找出所有这样的三个数字，使得任意两个数字之和都大于第三个数字。如果三个数字中如果较小的两个数字之和大于第三个数字，那么任意两个数字之和都大于第三个数字。

**解题思路**

1. 排序 + 二分查找
   - 先确定前两个数，将这两个数之和 sum 作为目标值，然后用二分查找法快速确定第一个大于等于目标值的下标，下标减一为最后一格小于目标值的数字。
   - 时间复杂度为 O(n^2logn)
2. 排序 + 双指针
   - left 指向首数字，从右往左固定最长边，开始循环
   - 如果 left 小于 right 就进行循环，循环里面判断如果 left 指向的数加上 right 指向的数大于当长边，那么 right 到 left之间的数字都可以组成三角形
   - 时间复杂度为 O(n^2)

## 617

**题目描述**

合并两个二叉树，规则是，都存在的结点，就将结点值加起来，否则空的位置就由另一个树的结点来代替。

**解题思路**

1. 递归
   - 如果 t1 不存在，则直接返回 t2
   - 如果 t2 不存在，则直接返回 t1
   - 如果上面两种情况都不满足，那么以 t1 和 t2 的结点值之和建立新结点 t，然后对 t1 和 t2 的左子结点调用递归并赋给 t 的左子结点，再对 t1 和 t2 的右子结点调用递归并赋给 t 的右子结点，返回 t 结点即可

## 628

**题目描述**

数组中最大的三个数乘积

**解题思路**

1. 排序+分类讨论
   - (1) 全正数：最大的三个数之乘积
   - (2) 全负数：最大的三个数之乘积
   - (3) 正负混合：最大的数和最小两个数的乘积或者最大的三个数之乘积。
2. 在方法 1 的基础上，因为只需要求最大和最小的几个数，可将时间复杂度降低为 O(n)。

## 637

**题目描述**

求一个二叉树每层的平均值。

**解题思路**

1. 层序遍历
2. 先序遍历

## 646

**题目描述**

给定一些链对，规定了如果后面链对的首元素大于前链对的末元素，那么这两个链对就可以链起来，问最大能链多少个。

**解题思路**

1. 排序 + 贪心算法
   - 按链对的尾元素进行排序，小的放前面。
   - 用一个变量 end 来记录当前比较到的尾元素的值，初始化为最小值，然后遍历的时候，如果当前链对的首元素大于 end，那么结果 res 自增 1，end 更新为当前链对的尾元素

## 647

**题目描述**

统计回文子串的数目。

**解题思路**

1. 动态规划
   - 二维数组dp[i][j]来记录子字符串 [i, j] 是否是回文串
   - 如果 s[i] 和 s[j] 相等，需要看 i 和 j 的位置关系
   - 如果 i 和 j 是相邻的，dp[i][j] = true；
   - 如果 i 和 j 中间只有一个字符，dp[i][j] = true；
   - 如果中间有多于一个字符存在，dp[i][j] = dp[i+1][j-1]

## 653

**题目描述**

两数之和: BST

**解题思路**

1. 前序遍历 + HashSet

## 657

**题目描述**

机器人可以走上下左右四个方向，给定机器人的路径，判断是否在绕圈，即最后是否回到了原点。

**解题思路**

1. U 和 D 的数量必须相等，L 和 R 的数量必须相等。

## 661

**题目描述**

图片平滑，即取位置点周围包含自身的九个点取平均值。

**解题思路**

1. 依照题意处理即可。

## 674

**题目描述**

求一个数组的最长连续递增序列长度。

**解题思路**

1. 每次都和前面一个数字来比较，使用一个计数器，如果遇到大的数字，计数器自增1；如果是一个小的数字，则计数器重置为1。

## 680

**题目描述**

验证回文字符串，允许最多删除其中 1 个字符。

**解题思路**

1. 遇到不匹配的时候，是删除左边的字符，还是右边的字符呢，应该是两种情况都要算一遍，只要有一种能返回 true，那么结果就返回 true。

## 682

**题目描述**

棒球比赛计分

**解题思路**

1. 按照题意处理即可。

## 690

**题目描述**

定义了一种员工类，有id，重要度和直接下属，计算某个员工的重要度，注意下属的重要度会向上累积到上级的重要度。

**解题思路**

1. 建图+DFS: 首先为需要建立一个id和员工类的映射，从而能够快速通过id来定位到员工类。
2. 建图+BFS

## 693

**题目描述**

判断一个二进制数的 1 和 0 是否是交替出现的

**解题思路**

1. 可以通过 异或 1 的方式来将 0 和 1 互换
   - while 循环的条件是最低位等于 d，而 d 不停的在 0 和 1 之间切换，n 每次也向右平移一位，这样能交替检测 0 和 1
   - 循环退出后，如果 n 为 0，则返回 true，反之则返回 false。
2. 错位相加
   - 比如 n 是10101，那么 n>>1 就是1010，二者相加就是 11111，再加 1 就是 100000，二者相与就是0
3. 先将 n 右移两位，再和原来的 n 异或，得到的结果其实就是除了最高位，其余都是 0 的数，然后再和自身减 1 的数相与，如果是 0 就返回 true，反之 false。
   - 比如 n 是 10101，那么 n/4 是 101，二者相异或，得到 10000，此时再减 1，为 1111，二者相与得 0

**边界条件**

1. n = 1431655765，经过 `((n >> 1) ^ n)` 后得到 INT_MAX，加 1 会溢出。

## 696

**题目描述**

给定一个字符串 s，计算具有相同数量 0 和 1 的非空（连续）子字符串的数量，并且这些子字符串中的所有 0 和所有 1 都是连续的。

**解题思路**

1. 动态规划：dp[i] 表示截止到 i 位置且包含 i 位置的有效字符长度，分两种情况讨论。s[i] == s[i-1] 时，就要将 dp[i-1] 视为内字符串，在内字符串的两边加上 s[i] 和 s[i-dp[i-1]-1]，要求这两个字符不能相同；s[i] != s[i-1] 时，就可以直接视作长度为 2 的有效字符串。

## 697

**题目描述**

数组的度定义为出现最多次数的数字的出现次数，求和原数组度相同的长度最小的子数组。

**解题思路**

1. HashMap
   - 统计数组元素的出现次数，以及数组元素的右边界，用 HashMap 进行统计存储
   - 得到最大出现次数后，从左往右遍历，依次计算元素是否符合最大出现次数，如果符合就计算区间长度，并将出现次数减一，防止后续重复计算。
2. 方法 1 的改进，统计数组元素的出现次数，以及数组元素的左边界，这样只需要遍历一次数组，遍历到的当前位置视为尾位置。

## 700

**题目描述**

搜索二叉搜索树

**解题思路**

1. 递归
2. 迭代

## 701

**题目描述**

插入二叉搜索树

**解题思路**

1. 检索到空节点时候新建一个节点返回

## 703

**题目描述**

在数据流中求第K大的元素。

**解题思路**

1. 最小堆，用来保存最大的 K 个数字，每次要加入数字前，先和堆顶进行比较，如果比堆顶小直接舍去即可，如果比堆顶大，先入堆再把堆顶弹出，始终保持堆顶是第 K 大的数字。

**边界条件**

1. 注意在 add 时候数组可能不满 k 个（这个边界条件确实挺弱智的）

## 709

**题目描述**

将单词转为小写

**解题思路**

1. 小写字母比其对应的大写字母的 ASCII 码大 'a'-'A

## 710

**题目描述**

随机生成一个 N 以内的数字，且该数字不能在黑名单中

**解题思路**

1. 首先将超过N - blacklist.size()的数字放入一个HashSet；然后遍历blacklist中的数字，如果在HashSet中的话，就将其删除；遍历黑名单中的数字，如果小于N - blacklist.size()的话，就和和HashSet中的数字建立映射。

## 713

**题目描述**

给定我们一个数组和一个数字K，让求子数组(子数组必须是连续的)且满足乘积小于K的个数

**解题思路**

1. 滑动窗口: 维护一个数字乘积刚好小于k的滑动窗口，每次向右移动边界时积累结果。

**FollowUp**

1. 不是子数组而是子序列
2. 存在小于等于 0 的数字

## 717

**题目描述**

有两种特殊的字符，一种是两位字符，只能是二进制的 11 和 10，另一种是单个位字符，只能是二进制的 0。现在给定一个只包含 0 和 1 的数组，问能否将其正确分割，使得最后一个字符是个单个位字符。

**解题思路**

1. 动态规划：从后往前看，最后一位必然有效，倒数第二位如果为 1 必然无效。从第三位开始，当前位为 1 时，说明其能够与后面一位组成有效字符，为 0 时肯定为有效字符。

## 718

**题目描述**

最长公共子数组。

**解题思路**

1. 动态规划
   - dp[i][j] 表示数组 A 的前 i 个数字和数组 B 的前 j 个数字在尾部匹配的最长子数组的长度
   - 如果 dp[i][j] 不为0，则 A 中第 i 个数组和 B 中第 j 个数字必须相等，且 dp[i][j] 的值就是往前推分别相等的个数。

## 739

**题目描述**

在数组里找下一个比当前数字大的数字的距离

**解题思路**

1. 单调栈：栈里面存值索引，当遇到比栈顶大的元素，就不断弹出栈顶并更新栈顶对应的间隔，然后推新数入栈。

## 769

**题目描述**

一个长度为 n 的无序数组，里面的数字是 [0, n-1] 范围内的所有数字，现在分成若干块，每一小块分别排序，再组合到一起，使原数组变得有序，最多能分多少块。

**解题思路**

1. 思路参见 <769. Max Chunks To Make Sorted>，维护一个最远能到达的位置，数组的每个数字相当于跳力，只有当刚好到达最远点的时候，才可以把之前断成一个新的块。

## 785

**题目描述**

存在一个无向图 ，图中有 n 个节点。其中每个节点都有一个介于 0 到 n - 1 之间的唯一编号。给定一个二维数组 graph ，其中 graph[u] 是一个节点数组，由节点 u 的邻接节点组成。形式上，对于 graph[u] 中的每个 v ，都存在一条位于节点 u 和节点 v 之间的无向边。

该无向图同时具有以下属性：
(1) 不存在自环（graph[u] 不包含 u）。
(2) 不存在平行边（graph[u] 不包含重复值）。
(3) 如果 v 在 graph[u] 内，那么 u 也应该在 graph[v] 内（该图是无向图）。
(4) 这个图可能不是连通图，也就是说两个节点 u 和 v 之间可能不存在一条连通彼此的路径。

二分图：如果能将一个图的节点集合分割成两个独立的子集 A 和 B ，并使图中的每一条边的两个节点一个来自 A 集合，一个来自 B 集合，就将这个图称为 二分图 。

**解题思路**

1. 并查集
   - 连接的两个节点不能在同一集合中
   - 同一节点的邻接节点必须在同一集合中
2. DFS 染色
   - 使用两种颜色，分别用 1 和 -1 来表示
   - 初始时每个顶点用 0 表示未染色，然后遍历每一个顶点，如果该顶点未被访问过，则调用递归函数
   - 在递归函数中，如果当前顶点已经染色，如果该顶点的颜色和将要染的颜色相同，则返回 true，否则返回 false。如果没被染色，则将当前顶点染色，然后再遍历与该顶点相连的所有的顶点
3. BFS 染色
   - 遍历所有顶点，如果未被染色，则先染色为 1，然后使用 BFS 进行遍历，将当前顶点放入队列 queue 中
   - while 循环：queue 不为空，取出队首元素，遍历其所有相邻的顶点，如果相邻顶点未被染色，则染成和当前顶点相反的颜色，然后把相邻顶点加入 queue 中，否则如果当前顶点和相邻顶点颜色相同，直接返回 false，循环退出后返回 true

## 820

**题目描述**

给定一个单词列表，将这个列表编码成一个索引字符串 S 与一个索引列表 A。例如，如果这个列表是 ["time", "me", "bell"]，可以将其表示为 S = "time#bell#" 和 indexes = [0, 2, 5]。对于每一个索引，可以通过从字符串 S 中索引的位置开始读取字符串，直到 "#" 结束，来恢复之前的单词列表。返回成功对给定单词列表进行编码的最小字符串长度。

题目本质是计算单词后缀，当一个单词是另外一个单词的后缀时，需要将当前单词去掉。

**解题思路**

1. 后缀匹配变前缀匹配
   - 对每个单词都做反转处理
   - 判断前一个字符串是否是后一个字符串的前缀，是的话长度加0，不是的话要加上当前单词的长度并再加 1，多加的 1 是 # 号。
   - 最后记得加上最后一个单词的长度
2. HashSet
   - 将所有的单词先放到 HashSet 中
   - 对于每个单词，我们遍历其所有的后缀，比如time，那么就遍历ime，me，e，然后看HashSet中是否存在这些后缀，有的话就删掉，那么HashSet中的me就会被删掉，这样保证了留下来的单词不可能再合并了，最后再加上每个单词的长度到结果res

**边界条件**

1. ["aba", "a"]

## 874

**题目描述**

机器人在一个无限大小的 XY 网格平面上行走，从点 (0, 0) 处开始出发，面向北方。该机器人可以接收以下三种类型的命令 commands：(1) -2:向左转 90 度；(2) -1:向右转 90 度；(3) 1 <= x <= 9 ：向前移动 x 个单位长度。在网格上有一些格子被视为障碍物 obstacles。第 i 个障碍物位于网格点 obstacles[i] = (xi, yi) 。机器人无法走到障碍物上，它将会停留在障碍物的前一个网格方块上，但仍然可以继续尝试进行该路线的其余部分。返回从原点到机器人所有经过的路径点（坐标为整数）的最大欧式距离的平方。

**解题思路**

1. 依照题意进行处理
   - 建立方向数组，方向数组的顺序应该是上右下左。
   - HashSet 将所有的障碍物位置存进去，可以将横纵坐标都转为字符串，然后在中间加个短横杆隔开
   - 行走过程中查看有没有障碍物，到 HashSet 中去查找一下，若没有障碍物，则可以到达，更新 x 和 y 为新的位置

## 886

**题目描述**

把每个人分进任意大小的两组。每个人都可能不喜欢其他人，那么他们不应该属于同一组。当可以用这种方法将所有人分进两组时，返回 true；否则返回 false。本质为二分图问题。

**解题思路**

解法同 <785. Is Graph Bipartite?>

1. 并查集

## 900

**题目描述**

每两个数字组成一个数字对，前一个数字表示后面数字重复出现的次数。实现一个 next 函数返回数组的第 n 个数字。

**解题思路**

1. 用一个指针 cur，指向当前数字对的次数。
   - 在 next 函数中，在 while 循环中判断 cur 是否越界
   - 当 n 大于当前次数，n 减去当前次数，cur 自增 2，移动到下一个数字对的次数上。
   - 当 while 循环结束后，判断此时 cur 是否越界。

## 978

**题目描述**

定义一种湍流子数组，即数字增减交替，就是先增大再减小再增大等交替进行，或者是先减小再增大再减小等交替进行的。找出最长的湍流子数组，并返回长度。

**解题思路**

1. 动态规划
   - dec[i] 表示湍流数组的长度，同时其末尾是数字是 arr[i] 且是下降的，同理，inc[i] 表示湍流数组的长度，同时其末尾是数字是 arr[i] 且是上升的
   - 若前一个数字大于当前数字，则表示下降的关系，则可以更新 dec[i] 为 inc[i-1] + 1，反之，若前一个数字小于当前数字，则表示上升的关系，则可以更新 inc[i] 为 dec[i-1] + 1。
   - 每次更新完一个位置，从 dec[i] 和 inc[i] 中找出最大的位置，用来更新结果 res 即可
2. 进一步简化，用两个变量 inc 和 dec 表示当前位置的递增长度和递减长度。

## 1143

**题目描述**

最长公共子序列。

**解题思路**

1. 动态规划
   - dp[i][j] 表示 text1 的前 i 个字符和 text2 的前 j 个字符的最长相同的子序列的字符个数
   - 若二者对应位置的字符相同，表示当前的 LCS 又增加了一位，所以 `dp[i][j] = dp[i-1][j-1] + 1`。
   - 若对应位置的字符不相同，由于是子序列，还可以错位比较，可以分别从 text1 或者 text2 去掉一个当前字符，`dp[i][j] = max( dp[i-1][j], dp[i][j-1])`。

## 1306

**题目描述**

一个非负整数数组 arr，最开始位于该数组的起始下标 start 处。位于下标 i 处时，可以跳到 i + arr[i] 或者 i - arr[i]。判断自己是否能够跳到对应元素值为 0 的任一下标处。

**解题思路**

1. BFS + 队列
   - 建立一个 visited 数组，记录每个下标是否已经被访问过
   - 队列中放入初始下标，之后每次循环都将队列顶端的左跳点和右跳点都放入队列
   - 放入队列前需要做合法性检查

## 1340

**题目描述**

给定一个整数数组 arr 和一个整数 d。每一步可以从下标 i 跳到：

(1) i + x ，其中 i + x < arr.length 且 0 < x <= d 。
(2) i - x ，其中 i - x >= 0 且 0 < x <= d 。

除此以外，从下标 i 跳到下标 j 需要满足：arr[i] > arr[j] 且 arr[i] > arr[k] ，其中下标 k 是所有 i 到 j 之间的数字（更正式的，min(i, j) < k < max(i, j)）。

可以选择数组的任意下标开始跳跃，返回最多可以访问多少个下标。

**解题思路**

undefined

## 1345

**题目描述**

一个整数数组 arr ，一开始在数组的第一个元素处（下标为 0），每一步可以从下标 i 跳到下标 i + 1 、i - 1 或者 j ：

(1) i + 1 需满足：i + 1 < arr.length
(2) i - 1 需满足：i - 1 >= 0
(3) j 需满足：arr[i] == arr[j] 且 i != j

返回到达数组最后一个元素的下标处所需的最少操作次数。

**解题思路**

1. BFS + HashMap
   - 每次循环需要将当前下标-1、当前下标+1、所有同元素的下标塞入队列
   - 记录一个 visited 数组
   - 优化操作：使用 HashMap 存储相同元素的下标集合
   - 优化操作：每次塞入队列后，HashMap 对应的下标集合需要清空防止后续重复操作
   - 优化操作：为了防止连续重复数字，需要做点压缩，超过 2 个连续相同数字压缩成只有 2 个数字
   - 优化操作：提前返回，在塞入队列时进行终止判断

**边界条件**

1. 数字交替出现，[1,2,1,2,1,2,1]
2. 大量重复出现的元素，[2,2,2,2,2,2]

## 1696

**题目描述**

给定一个下标从 0 开始的整数数组 nums 和一个整数 k。一开始在下标 0 处，每一步最多可以往前跳 k 步，但不能跳出数组的边界，即可以从下标 i 跳到 [i + 1， min(n - 1, i + k)] 包含两个端点的任意位置。目标是到达数组最后一个位置，得分为经过的所有数字之和。返回能得到的最大得分。

**解题思路**

1. 单调队列
   - dp[i] 表示到达点 i 能得到的最大得分
   - 跳到坐标 x 时，其追溯的坐标范围为 [x-k, x-1]，dp[x] = max(dp[x-k], dp[x-k+1], ..., dp[x-1])
   - 使用单调递减队列存储 i 之前的位置获得的最大和

Error: .doc\175.combine-two-tables.md, local variable 'desc_idx' referenced before assignment
Error: .doc\176.second-highest-salary.md, local variable 'desc_idx' referenced before assignment
Error: .doc\177.nth-highest-salary.md, local variable 'desc_idx' referenced before assignment
Error: .doc\178.rank-scores.md, local variable 'desc_idx' referenced before assignment
Error: .doc\180.consecutive-numbers.md, local variable 'desc_idx' referenced before assignment
Error: .doc\181.employees-earning-more-than-their-managers.md, local variable 'desc_idx' referenced before assignment
Error: .doc\182.duplicate-emails.md, local variable 'desc_idx' referenced before assignment
Error: .doc\183.customers-who-never-order.md, local variable 'desc_idx' referenced before assignment
Error: .doc\184.department-highest-salary.md, local variable 'desc_idx' referenced before assignment
Error: .doc\185.department-top-three-salaries.md, local variable 'desc_idx' referenced before assignment
Error: .doc\192.word-frequency.md, local variable 'desc_idx' referenced before assignment
Error: .doc\193.valid-phone-numbers.md, local variable 'desc_idx' referenced before assignment
Error: .doc\194.transpose-file.md, local variable 'desc_idx' referenced before assignment
Error: .doc\195.tenth-line.md, local variable 'desc_idx' referenced before assignment
Error: .doc\196.delete-duplicate-emails.md, local variable 'desc_idx' referenced before assignment
Error: .doc\197.rising-temperature.md, local variable 'desc_idx' referenced before assignment
Error: .doc\262.trips-and-users.md, local variable 'desc_idx' referenced before assignment
Error: .doc\511.game-play-analysis-i.md, local variable 'desc_idx' referenced before assignment
Error: .doc\584.find-customer-referee.md, local variable 'desc_idx' referenced before assignment
Error: .doc\586.customer-placing-the-largest-number-of-orders.md, local variable 'desc_idx' referenced before assignment
Error: .doc\595.big-countries.md, local variable 'desc_idx' referenced before assignment
Error: .doc\596.classes-more-than-5-students.md, local variable 'desc_idx' referenced before assignment
Error: .doc\601.human-traffic-of-stadium.md, local variable 'desc_idx' referenced before assignment
Error: .doc\607.sales-person.md, local variable 'desc_idx' referenced before assignment
Error: .doc\608.tree-node.md, local variable 'desc_idx' referenced before assignment
Error: .doc\620.not-boring-movies.md, local variable 'desc_idx' referenced before assignment
Error: .doc\626.exchange-seats.md, local variable 'desc_idx' referenced before assignment
Error: .doc\627.swap-salary.md, local variable 'desc_idx' referenced before assignment
